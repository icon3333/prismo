{% extends "base.html" %}
{% from "components/loading_components.html" import loading_indicator %}

{% block title %}Portfolio Analysis{% endblock %}

{% block content %}
<div class="container portfolio-analysis">
    <h1 class="page-title">Performance</h1>

    <!-- Loading indicator -->
    <div id="loadingIndicator">
        {{ loading_indicator('Loading portfolio data...') }}
    </div>

    <div id="analysisContent" style="display: none;">


        <!-- Portfolio Selection & Summary -->
        <section class="mb-6">
            <div class="box">
                <!-- Top row: dropdown + cash toggle -->
                <div class="performance-header">
                    <div class="performance-selector">
                        <span class="performance-selector-label">Portfolio</span>
                        <div class="select">
                            <select id="portfolioSelector">
                                <option value="">-- Loading --</option>
                            </select>
                        </div>
                        <!-- Cash Toggle -->
                        <div id="cashToggleContainer" class="cash-toggle-container" style="display: none;">
                            <label class="checkbox cash-toggle">
                                <input type="checkbox" id="includeCashToggle">
                                <span class="cash-toggle-label">
                                    <i class="fas fa-coins"></i>Cash
                                </span>
                                <span id="cashBalanceDisplay" class="tag is-info is-light cash-balance-tag sensitive-value"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- No portfolios message (hidden initially) -->
                <div id="noPortfoliosMessage" style="display: none;" class="notification is-info mt-4">
                    <p><strong>No portfolios with holdings found.</strong></p>
                    <p class="mt-2">Import holdings via CSV on the <a href="{{ url_for('main.index') }}">Overview</a> page.</p>
                </div>

                <!-- Summary Statistics (hidden initially) -->
                <div id="portfolioSummary" style="display: none;" class="mt-4">
                    <div class="columns is-mobile">
                        <div class="column has-text-centered">
                            <p class="heading">Value</p>
                            <p class="title is-5" id="summaryTotalValue">-</p>
                        </div>
                        <div class="column has-text-centered">
                            <p class="heading">P&L</p>
                            <p class="title is-5" id="summaryPnL">-</p>
                        </div>
                        <div class="column has-text-centered">
                            <p class="heading">Holdings</p>
                            <p class="title is-5" id="summaryHoldings">-</p>
                        </div>
                        <div class="column has-text-centered">
                            <p class="heading">Updated</p>
                            <p class="title is-5" id="summaryLastUpdated">-</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Portfolio Allocation Table + Performance Chart (hidden initially) -->
        <section id="portfolioTables" class="mb-6" style="display: none;">
            <div class="columns">
                <!-- Allocation Table (left) -->
                <div class="column is-6">
                    <div class="box">
                        <div class="is-flex is-justify-content-space-between is-align-items-center mb-3">
                            <h3 class="subtitle is-5 mb-0" id="allocationTableTitle">Thesis Allocation</h3>
                            <div class="toggle-group" id="allocationToggle">
                                <button class="toggle-btn" data-mode="portfolios" id="portfoliosToggle" style="display: none;">Portfolios</button>
                                <button class="toggle-btn active" data-mode="thesis">Thesis</button>
                                <button class="toggle-btn" data-mode="sector">Sector</button>
                                <button class="toggle-btn" data-mode="stocks">Stocks</button>
                            </div>
                        </div>
                        <!-- Unified Tabulator table for all modes -->
                        <div id="allocationTable"></div>
                    </div>
                </div>
                <!-- Performance Chart (right) -->
                <div class="column is-6">
                    <div class="box" id="performanceChartBox">
                        <div class="mb-3">
                            <h3 class="subtitle is-5 mb-2" id="performanceChartTitle">Returns</h3>
                            <div class="is-flex" style="gap: var(--space-sm, 8px); flex-wrap: wrap;">
                                <div class="toggle-group" id="chartModeToggle">
                                    <button class="toggle-btn active" data-mode="aggregate">Aggregate</button>
                                    <button class="toggle-btn" data-mode="detail">Detail</button>
                                </div>
                                <div class="toggle-group" id="periodToggle">
                                    <button class="toggle-btn" data-period="3y">3Y</button>
                                    <button class="toggle-btn active" data-period="5y">5Y</button>
                                    <button class="toggle-btn" data-period="10y">10Y</button>
                                    <button class="toggle-btn" data-period="max">MAX</button>
                                    <button class="toggle-btn" data-period="since_purchase">Since Purchase</button>
                                </div>
                            </div>
                        </div>
                        <!-- Chart container -->
                        <div id="performanceChart" style="min-height: 350px; display: none;"></div>
                        <!-- Loading spinner -->
                        <div id="performanceChartLoading" style="display: none;" class="has-text-centered p-6">
                            <div class="chart-spinner"></div>
                        </div>
                        <!-- Empty state -->
                        <div id="performanceChartEmpty" class="has-text-centered p-6">
                            <p class="has-text-grey">
                                <i class="fas fa-chart-line mr-2"></i>
                                Click a row to see performance over time
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Risk Breakdown Section -->
        <section class="mb-6">
            <h2 class="section-title">Concentration</h2>

            <!-- Sector vs Country Heatmap - Outside collapsible (always visible) -->
            <div class="mb-4">
                <div class="is-flex is-justify-content-space-between is-align-items-center mb-3">
                    <h4 class="subtitle is-5 mb-0" id="heatmapTitle">Sector vs Country</h4>
                    <div class="toggle-group" id="heatmapToggle">
                        <button class="toggle-btn active" data-mode="sector">Sector</button>
                        <button class="toggle-btn" data-mode="thesis">Thesis</button>
                    </div>
                </div>
                <div class="columns">
                    <div class="column is-full">
                        <div class="chart-large-container">
                            <div id="sectorHeatmap"></div>
                        </div>
                    </div>
                </div>
            </div>

        </section>
    </div>

    <!-- Include chart components -->
    {% include "components/performance_components.html" %}

    <!-- CSS has been moved to custom.css -->

    <!-- Load centralized value calculator utility -->
    <script src="{{ url_for('static', filename='js/utils/value-calculator.js') }}"></script>

    <!-- JavaScript for interactivity -->
    <script>
        /**
         * Enhanced Portfolio Analysis with Tabbed Interface
         * 
         * This script adds company-centric and sector-centric views to each portfolio section.
         * Features include:
         * - Sector breakdown with percentages relative to portfolio
         * - Expandable company rows within each sector
         * - Company percentages relative to their sector
         * - Sortable tables in both views
         * - Responsive charts for both views
         * - Sunburst visualization for sector breakdown
         * 
         * HEATMAP FIXES APPLIED:
         * - Fixed ApexCharts heatmap data format
         * - Added proper data validation and error handling
         * - Added fallback table-based heatmap for resilience
         * - Improved container visibility and dimension handling
         * - Added distribution chart containers
         */
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize Portfolio Analysis

            // Check if required dependencies are loaded
            if (typeof ApexCharts === 'undefined') {
                console.error('ApexCharts is not loaded');
                document.getElementById('loadingIndicator').innerHTML = `
            <div class="has-text-centered">
                <p class="has-text-danger mb-3">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    Required chart library (ApexCharts) is not loaded.
                </p>
                <button class="button is-info" onclick="location.reload()">
                    <i class="fas fa-refresh mr-2"></i>Try Again
                </button>
            </div>
        `;
                return;
            }

            // State management
            let portfolios = [];
            let selectedPortfolioId = null;
            let selectedPortfolioIds = [];  // Needed by heatmap
            let currentPortfolioData = null;
            let allocationMode = 'thesis'; // 'portfolios', 'thesis', 'sector', or 'stocks'
            let heatmapMode = 'sector'; // 'sector' or 'thesis'
            let includeCash = false;
            let cashBalance = 0;

            // Performance chart state
            let currentChartPeriod = '5y';
            let currentChartMode = 'aggregate'; // 'aggregate', 'detail'
            let currentChartIdentifiers = [];
            let currentChartNames = [];
            let currentChartValues = [];
            let currentChartGroupName = '';
            let performanceChartInstance = null;
            let historicalDataCache = new Map();
            let chartAbortController = null;
            let selectedRow = null;

            // Make portfolioData available globally for heatmap
            window.portfolioData = [];

            // Persistent sort state (replaces WeakMap for persistence across page loads)
            let persistedSortState = {
                stockTable: { column: null, direction: 'asc' },
                sectorTable: { column: null, direction: 'asc' }
            };

            // Debounce utility for saving state
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Save sort state to server (debounced)
            const saveSortState = debounce(async function() {
                try {
                    await fetch('/portfolio/api/state', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            page: 'performance',
                            tableSortState: JSON.stringify(persistedSortState),
                            includeCash: includeCash.toString()
                        })
                    });
                } catch (error) {
                    console.warn('Failed to save sort state:', error);
                }
            }, 500);

            // Load sort state from server
            async function loadSortState() {
                try {
                    const response = await fetch('/portfolio/api/state?page=performance');
                    if (!response.ok) return;
                    const state = await response.json();
                    if (state.tableSortState) {
                        persistedSortState = JSON.parse(state.tableSortState);
                    }
                    // Restore includeCash state
                    if (state.includeCash !== undefined) {
                        includeCash = state.includeCash === 'true' || state.includeCash === true;
                        const toggle = document.getElementById('includeCashToggle');
                        if (toggle) toggle.checked = includeCash;
                    }
                } catch (error) {
                    console.warn('Failed to load sort state:', error);
                }
            }

            // Apply saved sort state to a table
            function applySortState(table) {
                const tableId = table.dataset.tableId;
                if (!tableId || !persistedSortState[tableId]) return;

                const savedState = persistedSortState[tableId];
                if (!savedState.column) return;

                const headers = table.querySelectorAll('th.is-sortable');
                for (const header of headers) {
                    const columnName = header.childNodes[0].textContent.trim();
                    if (columnName === savedState.column) {
                        // Apply sort
                        sortTableByHeader(table, header, savedState.direction);
                        break;
                    }
                }
            }

            // Format functions
            function formatCurrency(value) {
                if (value == null || isNaN(value)) value = 0;
                const formatted = '€' + value.toLocaleString('de-DE', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 2
                });
                return `<span class="sensitive-value">${formatted}</span>`;
            }

            function formatPercentage(value) {
                if (value == null || isNaN(value)) value = 0;
                return value.toFixed(1) + '%';
            }

            function formatPnL(pnlAbsolute, pnlPercentage, totalInvested) {
                // Handle N/A cases (null or undefined P&L values)
                if (pnlAbsolute === null || pnlAbsolute === undefined) {
                    return '<span class="has-text-grey-light">N/A</span>';
                }

                const absValue = parseFloat(pnlAbsolute);
                const pctValue = parseFloat(pnlPercentage);

                // Determine color class and sign
                let colorClass;
                let sign;

                if (absValue > 0) {
                    colorClass = 'has-text-success';
                    sign = '+';
                } else if (absValue < 0) {
                    colorClass = 'has-text-danger';
                    sign = '';  // Negative sign is part of the number
                } else {
                    colorClass = 'has-text-grey-light';
                    sign = '';
                }

                // Format absolute value and percentage
                const formattedAbs = formatCurrency(absValue);
                const formattedPct = `${sign}${Math.abs(pctValue).toFixed(1)}%`;

                // Build tooltip with total invested value (use raw format for title attribute)
                const tooltipRaw = totalInvested !== undefined && totalInvested !== null
                    ? `€${parseFloat(totalInvested).toLocaleString('de-DE', {minimumFractionDigits: 0, maximumFractionDigits: 2})}`
                    : '';
                const tooltipText = tooltipRaw ? `Total Invested: ${tooltipRaw}` : '';

                // Return formatted P&L with tooltip
                return `<span class="${colorClass}" title="${tooltipText}">${formattedAbs} (${formattedPct})</span>`;
            }

            // Make format functions available globally for components
            window.formatCurrency = formatCurrency;
            window.formatPercentage = formatPercentage;
            window.formatPnL = formatPnL;

            // Table sorting functionality with persistent state
            function initTableSorting() {
                document.querySelectorAll('table[data-table-id]').forEach(table => {
                    const tableId = table.dataset.tableId;
                    const headers = table.querySelectorAll('th.is-sortable');

                    // Skip if already initialized
                    if (table.dataset.sortingInitialized === 'true') {
                        applySortState(table);
                        return;
                    }
                    table.dataset.sortingInitialized = 'true';

                    // Initialize state for this table if not exists
                    if (!persistedSortState[tableId]) {
                        persistedSortState[tableId] = { column: null, direction: 'asc' };
                    }

                    // Use event delegation: attach ONE listener to the table
                    table.addEventListener('click', function(e) {
                        const header = e.target.closest('th.is-sortable');
                        if (!header) return;

                        const columnName = header.childNodes[0].textContent.trim();
                        const currentState = persistedSortState[tableId];

                        // Determine new direction
                        let newDirection = 'asc';
                        if (currentState.column === columnName) {
                            newDirection = currentState.direction === 'asc' ? 'desc' : 'asc';
                        }

                        // Update persisted state
                        persistedSortState[tableId] = {
                            column: columnName,
                            direction: newDirection
                        };

                        // Apply sort
                        sortTableByHeader(table, header, newDirection);

                        // Save state to server
                        saveSortState();
                    });

                    // Apply saved state after initialization
                    applySortState(table);
                });

                // DEBUG: Log initialization status
                const allTables = document.querySelectorAll('table[data-table-id]');

                // Initialize P&L column sorting
                initPnLSorting();
            }

            // P&L column sorting (€ or % toggles)
            function initPnLSorting() {
                document.querySelectorAll('.pnl-sort-toggle').forEach(toggle => {
                    // Skip if already initialized
                    if (toggle.dataset.initialized === 'true') return;
                    toggle.dataset.initialized = 'true';

                    toggle.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent bubbling to header click

                        const sortType = this.dataset.sortType; // 'pnl-eur' or 'pnl-pct'
                        const table = this.closest('table');
                        const tableId = table.dataset.tableId;

                        // Initialize state for this table if not exists
                        if (!persistedSortState[tableId]) {
                            persistedSortState[tableId] = { column: null, direction: 'asc' };
                        }

                        const currentState = persistedSortState[tableId];

                        // Determine new direction
                        let newDirection = 'desc'; // Default to descending (highest first)
                        if (currentState.column === sortType) {
                            newDirection = currentState.direction === 'asc' ? 'desc' : 'asc';
                        }

                        // Update persisted state
                        persistedSortState[tableId] = {
                            column: sortType,
                            direction: newDirection
                        };

                        // Apply P&L sort
                        sortTableByPnL(table, sortType, newDirection);

                        // Update visual indicators
                        updatePnLSortIndicators(table, sortType, newDirection);

                        // Save state to server
                        saveSortState();
                    });
                });
            }

            // Sort table by P&L value (€ or %)
            function sortTableByPnL(table, sortType, direction) {
                const tbody = table.querySelector('tbody');
                const tableId = table.dataset.tableId;
                const rows = Array.from(tbody.querySelectorAll('tr:not(.sector-company):not(.sector-companies)'));
                const isAsc = direction === 'asc';

                // Clear previous sort indicators on regular headers
                table.querySelectorAll('th.is-sortable').forEach(th => {
                    th.classList.remove('is-sorted-asc', 'is-sorted-desc');
                });

                // Sort rows by P&L data attribute
                rows.sort((a, b) => {
                    const pnlCellA = a.querySelector(`td[data-${sortType}]`);
                    const pnlCellB = b.querySelector(`td[data-${sortType}]`);

                    const valA = pnlCellA ? parseFloat(pnlCellA.dataset[sortType === 'pnl-eur' ? 'pnlEur' : 'pnlPct']) : -Infinity;
                    const valB = pnlCellB ? parseFloat(pnlCellB.dataset[sortType === 'pnl-eur' ? 'pnlEur' : 'pnlPct']) : -Infinity;

                    return isAsc ? valA - valB : valB - valA;
                });

                // Reorder rows
                if (tableId === 'sectorTable') {
                    rows.forEach(sectorRow => {
                        const sectorName = sectorRow.dataset.sector;
                        const portfolioId = sectorRow.dataset.portfolioId;
                        tbody.appendChild(sectorRow);

                        // Find and append related company rows
                        if (sectorName) {
                            let selector = portfolioId
                                ? `.sector-companies[data-parent-sector="${sectorName}"][data-portfolio-id="${portfolioId}"], .sector-company[data-parent-sector="${sectorName}"][data-portfolio-id="${portfolioId}"]`
                                : `.sector-company[data-parent-sector="${sectorName}"]`;
                            const companyRows = tbody.querySelectorAll(selector);
                            companyRows.forEach(row => tbody.appendChild(row));
                        }
                    });
                } else {
                    rows.forEach(row => tbody.appendChild(row));
                }
            }

            // Update visual indicators for P&L sort
            function updatePnLSortIndicators(table, sortType, direction) {
                // Remove active class from all toggles in this table
                table.querySelectorAll('.pnl-sort-toggle').forEach(t => {
                    t.classList.remove('pnl-sort-active', 'pnl-sort-asc', 'pnl-sort-desc');
                });

                // Add active class to the current toggle
                const activeToggle = table.querySelector(`.pnl-sort-toggle[data-sort-type="${sortType}"]`);
                if (activeToggle) {
                    activeToggle.classList.add('pnl-sort-active');
                    activeToggle.classList.add(direction === 'asc' ? 'pnl-sort-asc' : 'pnl-sort-desc');
                }
            }

            // Sort a table by clicking a header
            function sortTableByHeader(table, header, direction) {
                const tbody = table.querySelector('tbody');
                const tableId = table.dataset.tableId;
                // Exclude both sector-company (static table) and sector-companies (dynamic table)
                const rows = Array.from(tbody.querySelectorAll('tr:not(.sector-company):not(.sector-companies)'));
                const index = Array.from(header.parentNode.children).indexOf(header);
                const sortType = header.dataset.sort || 'string';
                const isAsc = direction === 'asc';

                // Clear previous sort indicators
                table.querySelectorAll('th.is-sortable').forEach(th => {
                    th.classList.remove('is-sorted-asc', 'is-sorted-desc');
                });

                // Add current sort indicator
                header.classList.add(isAsc ? 'is-sorted-asc' : 'is-sorted-desc');

                // Sort rows
                rows.sort((a, b) => {
                    const cellA = a.querySelectorAll('td')[index]?.textContent.trim() || '';
                    const cellB = b.querySelectorAll('td')[index]?.textContent.trim() || '';

                    if (sortType === 'number') {
                        const numA = parseFloat(cellA.replace(/[€%,]/g, '').replace(/\./g, '').replace(',', '.')) || 0;
                        const numB = parseFloat(cellB.replace(/[€%,]/g, '').replace(/\./g, '').replace(',', '.')) || 0;
                        return isAsc ? numA - numB : numB - numA;
                    } else {
                        return isAsc ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
                    }
                });

                // For category table, need to keep company rows with their categories
                if (tableId === 'sectorTable') {
                    rows.forEach(sectorRow => {
                        const sectorName = sectorRow.dataset.sector;
                        const portfolioId = sectorRow.dataset.portfolioId;
                        tbody.appendChild(sectorRow);

                        // Find and append related company rows
                        if (sectorName) {
                            // Handle both static table (.sector-company) and dynamic table (.sector-companies)
                            let selector = portfolioId
                                ? `.sector-companies[data-parent-sector="${sectorName}"][data-portfolio-id="${portfolioId}"], .sector-company[data-parent-sector="${sectorName}"][data-portfolio-id="${portfolioId}"]`
                                : `.sector-company[data-parent-sector="${sectorName}"]`;
                            const companyRows = tbody.querySelectorAll(selector);
                            companyRows.forEach(row => tbody.appendChild(row));
                        }
                    });
                } else {
                    rows.forEach(row => tbody.appendChild(row));
                }
            }

            // Initialize expandable portfolio sections
            function initializeExpandablePortfolios() {
                // Add click handlers for the expand/collapse all buttons
                const expandAllBtn = document.getElementById('expandAllPortfolios');
                const collapseAllBtn = document.getElementById('collapseAllPortfolios');

                if (expandAllBtn && collapseAllBtn) {
                    // Add click handler for expand all button
                    expandAllBtn.addEventListener('click', function () {
                        const allSections = document.querySelectorAll('.portfolio-section');

                        allSections.forEach(section => {
                            const content = section.querySelector('.portfolio-content');
                            const icon = section.querySelector('.toggle-portfolio i');

                            content.style.display = 'block';
                            icon.classList.remove('fa-chevron-down');
                            icon.classList.add('fa-chevron-up');
                        });

                        // Ensure charts render correctly
                        window.dispatchEvent(new Event('resize'));
                    });

                    // Add click handler for collapse all button
                    collapseAllBtn.addEventListener('click', function () {
                        const allSections = document.querySelectorAll('.portfolio-section');

                        allSections.forEach(section => {
                            const content = section.querySelector('.portfolio-content');
                            const icon = section.querySelector('.toggle-portfolio i');

                            content.style.display = 'none';
                            icon.classList.remove('fa-chevron-up');
                            icon.classList.add('fa-chevron-down');
                        });
                    });
                }
            }

            // NEW INITIALIZATION LOGIC - Portfolio Dropdown Selector
            // ======================================================

            async function initializePage() {
                try {
                    // Load saved sort state first (also restores includeCash)
                    await loadSortState();

                    // Load portfolios and cash balance in parallel
                    const [_, cash] = await Promise.all([
                        loadPortfolios(),
                        fetchCashBalance()
                    ]);

                    // Store cash balance and update display
                    cashBalance = cash || 0;
                    updateCashDisplay();
                    initCashToggle();

                    // Try to restore last selected portfolio
                    const savedPortfolioId = await loadSavedPortfolioSelection();

                    if (savedPortfolioId) {
                        document.getElementById('portfolioSelector').value = savedPortfolioId;
                        await loadPortfolioData(savedPortfolioId);
                    }

                    // Hide loading, show content
                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.getElementById('analysisContent').style.display = 'block';

                    // Initialize table sorting and toggles
                    initTableSorting();
                    initAllocationToggle();
                    initHeatmapToggle();
                    initPeriodToggle();
                    initChartModeToggle();
                    setupThemeChangeHandler();

                    // Initialize concentration heatmap if no portfolio was already loaded
                    // (loadPortfolioData already calls initializeRiskBreakdown with valid data)
                    if (selectedPortfolioIds.length === 0) {
                        initializeRiskBreakdown();
                    }
                } catch (error) {
                    console.error('Error initializing page:', error);
                    showError('Failed to load portfolio data. Please try again.');
                }
            }

            // Fetch cash balance from account
            async function fetchCashBalance() {
                try {
                    const response = await fetch('/portfolio/api/account/cash');
                    if (!response.ok) return 0;
                    const data = await response.json();
                    return data.cash || 0;
                } catch (error) {
                    console.warn('Error fetching cash balance:', error);
                    return 0;
                }
            }

            // Show/hide cash toggle based on cash balance
            function updateCashDisplay() {
                const container = document.getElementById('cashToggleContainer');
                const cashDisplay = document.getElementById('cashBalanceDisplay');
                if (container) {
                    container.style.display = cashBalance > 0 ? '' : 'none';
                }
                if (cashDisplay && cashBalance > 0) {
                    cashDisplay.textContent = '€' + cashBalance.toLocaleString('de-DE', {
                        minimumFractionDigits: 0, maximumFractionDigits: 2
                    });
                    cashDisplay.classList.add('is-visible');
                }
            }

            // Initialize cash toggle event listener
            function initCashToggle() {
                const toggle = document.getElementById('includeCashToggle');
                if (toggle) {
                    toggle.addEventListener('change', function() {
                        includeCash = this.checked;
                        renderPortfolioDisplay();
                        initializeRiskBreakdown();
                        saveSortState();
                    });
                }
            }

            async function loadPortfolios() {
                const response = await fetch('/portfolio/api/portfolios?include_ids=true&has_companies=true');
                if (!response.ok) throw new Error('Failed to fetch portfolios');

                portfolios = await response.json();

                const selector = document.getElementById('portfolioSelector');
                const noPortfoliosMessage = document.getElementById('noPortfoliosMessage');

                // Check if there are any portfolios with holdings
                if (!portfolios || portfolios.length === 0) {
                    selector.innerHTML = '<option value="">-- No portfolios available --</option>';
                    noPortfoliosMessage.style.display = 'block';
                } else {
                    selector.innerHTML = '<option value="">-- Select a portfolio --</option>';
                    noPortfoliosMessage.style.display = 'none';

                    // Add "All Portfolios" option first (only if there are 2+ portfolios)
                    if (portfolios.length >= 2) {
                        const allOption = document.createElement('option');
                        allOption.value = 'all';
                        allOption.textContent = 'All Portfolios';
                        selector.appendChild(allOption);
                    }

                    portfolios.forEach(portfolio => {
                        const option = document.createElement('option');
                        option.value = portfolio.id;
                        option.textContent = portfolio.name;
                        selector.appendChild(option);
                    });
                }

                selector.addEventListener('change', handlePortfolioChange);
            }

            async function handlePortfolioChange(event) {
                const portfolioId = event.target.value;
                if (!portfolioId) {
                    hidePortfolioDisplay();
                    clearPerformanceChart();
                    return;
                }
                clearPerformanceChart();
                historicalDataCache.clear();
                await loadPortfolioData(portfolioId);
                await savePortfolioSelection(portfolioId);
            }

            async function loadPortfolioData(portfolioId) {
                try {
                    showLoadingState();

                    const response = await fetch(`/portfolio/api/portfolio_data/${portfolioId}`);
                    if (!response.ok) {
                        if (response.status === 404) throw new Error('Portfolio not found');
                        throw new Error('Failed to fetch portfolio data');
                    }

                    currentPortfolioData = await response.json();
                    renderPortfolioDisplay();

                    // Update heatmap with this portfolio's data
                    selectedPortfolioIds = [currentPortfolioData.portfolio_id];  // Update selected portfolio IDs
                    window.portfolioData = [{
                        id: currentPortfolioData.portfolio_id,
                        name: currentPortfolioData.portfolio_name,
                        companies: currentPortfolioData.companies
                    }];
                    initializeRiskBreakdown();

                } catch (error) {
                    console.error('Error loading portfolio:', error);
                    showError(`Failed to load portfolio: ${error.message}`);
                }
            }

            function renderPortfolioDisplay() {
                if (!currentPortfolioData) return;

                updateSummaryBox();
                updatePortfoliosToggleVisibility();  // Show/hide Portfolios tab based on selection
                renderAllocationTable();  // Use unified render based on current mode

                document.getElementById('portfolioSummary').style.display = 'block';
                document.getElementById('portfolioTables').style.display = 'block';

                hideLoadingState();  // Reset opacity and pointer-events
                initTableSorting();
            }

            function updateSummaryBox() {
                const displayValue = includeCash
                    ? currentPortfolioData.total_value + cashBalance
                    : currentPortfolioData.total_value;
                document.getElementById('summaryTotalValue').innerHTML = formatCurrency(displayValue);

                // Display portfolio P&L with color coding
                const pnlElement = document.getElementById('summaryPnL');
                pnlElement.innerHTML = formatPnL(
                    currentPortfolioData.portfolio_pnl_absolute,
                    currentPortfolioData.portfolio_pnl_percentage,
                    currentPortfolioData.total_invested
                );

                document.getElementById('summaryHoldings').textContent = currentPortfolioData.num_holdings;

                const lastUpdated = currentPortfolioData.last_updated
                    ? new Date(currentPortfolioData.last_updated).toLocaleDateString()
                    : 'Never';
                document.getElementById('summaryLastUpdated').textContent = lastUpdated;
            }

            /**
             * Show/hide the Portfolios toggle based on whether "All Portfolios" is selected.
             * Only makes sense to show portfolio breakdown when viewing all portfolios.
             */
            function updatePortfoliosToggleVisibility() {
                const portfoliosToggle = document.getElementById('portfoliosToggle');
                if (!portfoliosToggle) return;

                const isAllPortfolios = currentPortfolioData && currentPortfolioData.portfolio_id === 'all';

                if (isAllPortfolios) {
                    portfoliosToggle.style.display = '';  // Show
                } else {
                    portfoliosToggle.style.display = 'none';  // Hide
                    // If portfolios mode was active, switch to thesis
                    if (allocationMode === 'portfolios') {
                        allocationMode = 'thesis';
                        // Update active state on toggle buttons
                        const toggleGroup = document.getElementById('allocationToggle');
                        if (toggleGroup) {
                            toggleGroup.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                            const thesisBtn = toggleGroup.querySelector('[data-mode="thesis"]');
                            if (thesisBtn) thesisBtn.classList.add('active');
                        }
                    }
                }
            }

            // Tabulator instance for unified allocation table
            let allocationTable = null;

            function renderUnifiedTable() {
                // Check if Tabulator is available
                if (typeof Tabulator === 'undefined') {
                    console.error('Tabulator is not loaded');
                    document.getElementById('allocationTable').innerHTML = '<p class="has-text-danger">Table library not loaded</p>';
                    return;
                }

                // Calculate denominator including cash if toggled on
                const holdingsValue = currentPortfolioData.total_value;
                const cash = (includeCash && cashBalance > 0) ? cashBalance : 0;
                const denominator = holdingsValue + cash;
                const cashPct = denominator > 0 ? (cash / denominator * 100) : 0;
                const pct = (value) => denominator > 0 ? (value / denominator * 100) : 0;

                let tableData, columns, emptyMessage;
                const isStocksMode = allocationMode === 'stocks';

                if (isStocksMode) {
                    // Stocks mode: flat list of companies
                    tableData = (currentPortfolioData.companies || []).map(c => ({
                        name: c.name,
                        identifier: c.identifier,
                        current_value: c.current_value || 0,
                        sector: c.sector || 'Unassigned',
                        percentage: pct(c.current_value || 0),
                        total_value: c.current_value || 0,
                        pnl_absolute: c.pnl_absolute,
                        pnl_percentage: c.pnl_percentage,
                        total_invested: c.total_invested
                    }));
                    emptyMessage = 'No holdings';
                    columns = [
                        {
                            title: "Company",
                            field: "name",
                            widthGrow: 1,
                            formatter: function(cell) {
                                return escapeHtml(cell.getValue() || '');
                            }
                        },
                        {
                            title: "Sector",
                            field: "sector",
                            widthGrow: 1,
                            formatter: function(cell) {
                                return escapeHtml(cell.getValue() || '');
                            }
                        },
                        {
                            title: "%",
                            field: "percentage",
                            hozAlign: "right",
                            widthGrow: 0.6,
                            formatter: function(cell) {
                                return formatPercentage(cell.getValue());
                            }
                        },
                        {
                            title: "Value",
                            field: "total_value",
                            hozAlign: "right",
                            widthGrow: 0.8,
                            formatter: function(cell) {
                                return formatCurrency(cell.getValue());
                            }
                        },
                        {
                            title: "P&L <span class='tabulator-pnl-toggle' data-sort-type='pnl-eur' title='Sort by € value'>€</span> / <span class='tabulator-pnl-toggle' data-sort-type='pnl-pct' title='Sort by % value'>%</span>",
                            field: "pnl_absolute",
                            hozAlign: "right",
                            headerSort: false,
                            widthGrow: 1.2,
                            sorter: function(a, b, aRow, bRow, column, dir, sorterParams) {
                                const aData = aRow.getData();
                                const bData = bRow.getData();
                                const sortByPct = tabulatorPnLSortState.type === 'pnl-pct';
                                const aVal = sortByPct ? aData.pnl_percentage : aData.pnl_absolute;
                                const bVal = sortByPct ? bData.pnl_percentage : bData.pnl_absolute;
                                // Handle null/undefined - treat as -Infinity (sort to bottom in desc)
                                const aSafe = (aVal === null || aVal === undefined) ? -Infinity : aVal;
                                const bSafe = (bVal === null || bVal === undefined) ? -Infinity : bVal;
                                return aSafe - bSafe;
                            },
                            formatter: function(cell) {
                                const data = cell.getRow().getData();
                                return formatPnL(data.pnl_absolute, data.pnl_percentage, data.total_invested);
                            }
                        }
                    ];
                } else if (allocationMode === 'portfolios') {
                    // Portfolios mode: tree structure with portfolios as parents, companies as children
                    const dataSource = currentPortfolioData.portfolios || [];

                    tableData = dataSource.map(portfolio => {
                        const portfolioValue = portfolio.total_value || 0;

                        return {
                            name: portfolio.name,
                            percentage: pct(portfolioValue),
                            total_value: portfolioValue,
                            pnl_absolute: portfolio.pnl_absolute,
                            pnl_percentage: portfolio.pnl_percentage,
                            total_invested: portfolio.total_invested,
                            _children: portfolio.companies.map(c => {
                                const companyValue = c.current_value || 0;
                                return {
                                    name: c.name,
                                    identifier: c.identifier,
                                    current_value: companyValue,
                                    percentage: pct(companyValue),
                                    total_value: companyValue,
                                    pnl_absolute: c.pnl_absolute,
                                    pnl_percentage: c.pnl_percentage,
                                    total_invested: c.total_invested
                                };
                            })
                        };
                    });

                    emptyMessage = 'No portfolios';

                    columns = [
                        {
                            title: "Portfolio",
                            field: "name",
                            widthGrow: 1,
                            formatter: function(cell) {
                                return escapeHtml(cell.getValue() || '');
                            }
                        },
                        {
                            title: "%",
                            field: "percentage",
                            hozAlign: "right",
                            widthGrow: 0.6,
                            formatter: function(cell) {
                                const row = cell.getRow();
                                const data = row.getData();
                                const isChild = row.getTreeParent();

                                if (isChild) {
                                    // Child row: show % within portfolio (gray text)
                                    const pct = (data.percentage || 0).toFixed(1);
                                    return `<span class="has-text-grey">${pct}%</span>`;
                                }
                                return formatPercentage(cell.getValue());
                            }
                        },
                        {
                            title: "Value",
                            field: "total_value",
                            hozAlign: "right",
                            widthGrow: 0.8,
                            formatter: function(cell) {
                                return formatCurrency(cell.getValue());
                            }
                        },
                        {
                            title: "P&L <span class='tabulator-pnl-toggle' data-sort-type='pnl-eur' title='Sort by € value'>€</span> / <span class='tabulator-pnl-toggle' data-sort-type='pnl-pct' title='Sort by % value'>%</span>",
                            field: "pnl_absolute",
                            hozAlign: "right",
                            headerSort: false,
                            widthGrow: 1,
                            sorter: function(a, b, aRow, bRow, column, dir, sorterParams) {
                                const aData = aRow.getData();
                                const bData = bRow.getData();
                                const sortByPct = tabulatorPnLSortState.type === 'pnl-pct';
                                const aVal = sortByPct ? aData.pnl_percentage : aData.pnl_absolute;
                                const bVal = sortByPct ? bData.pnl_percentage : bData.pnl_absolute;
                                const aSafe = (aVal === null || aVal === undefined) ? -Infinity : aVal;
                                const bSafe = (bVal === null || bVal === undefined) ? -Infinity : bVal;
                                return aSafe - bSafe;
                            },
                            formatter: function(cell) {
                                const data = cell.getRow().getData();
                                return formatPnL(data.pnl_absolute, data.pnl_percentage, data.total_invested);
                            }
                        }
                    ];
                } else {
                    // Thesis/Sector mode: tree structure with expandable rows
                    const dataSource = allocationMode === 'thesis' ? currentPortfolioData.theses : currentPortfolioData.sectors;

                    tableData = (dataSource || []).map(category => {
                        const categoryValue = category.total_value || 0;

                        return {
                            name: category.name,
                            percentage: pct(categoryValue),
                            total_value: categoryValue,
                            pnl_absolute: category.pnl_absolute,
                            pnl_percentage: category.pnl_percentage,
                            total_invested: category.total_invested,
                            _children: category.companies.map(c => {
                                const companyValue = c.current_value || c.currentValue || 0;
                                const categoryPercent = categoryValue > 0
                                    ? (companyValue / categoryValue * 100)
                                    : 0;

                                return {
                                    name: c.name,
                                    identifier: c.identifier,
                                    current_value: companyValue,
                                    percentage: pct(companyValue),
                                    category_percentage: categoryPercent,
                                    total_value: companyValue,
                                    pnl_absolute: c.pnl_absolute,
                                    pnl_percentage: c.pnl_percentage,
                                    total_invested: c.total_invested || c.totalInvested
                                };
                            })
                        };
                    });

                    emptyMessage = allocationMode === 'thesis'
                        ? 'No thesis data. Add thesis in Enrich page.'
                        : 'No categories';

                    columns = [
                        {
                            title: allocationMode === 'thesis' ? "Thesis" : "Sector",
                            field: "name",
                            widthGrow: 1,
                            formatter: function(cell) {
                                return escapeHtml(cell.getValue() || '');
                            }
                        },
                        {
                            title: "%",
                            field: "percentage",
                            hozAlign: "right",
                            widthGrow: 0.6,
                            formatter: function(cell) {
                                const row = cell.getRow();
                                const data = row.getData();
                                const isChild = row.getTreeParent();

                                if (isChild) {
                                    // Child row: show category % and portfolio %
                                    const catPct = (data.category_percentage || 0).toFixed(1);
                                    const portfolioPct = (data.percentage || 0).toFixed(1);
                                    return `${catPct}% <span class="has-text-grey-light">(${portfolioPct}% total)</span>`;
                                }
                                return formatPercentage(cell.getValue());
                            }
                        },
                        {
                            title: "Value",
                            field: "total_value",
                            hozAlign: "right",
                            widthGrow: 0.8,
                            formatter: function(cell) {
                                return formatCurrency(cell.getValue());
                            }
                        },
                        {
                            title: "P&L <span class='tabulator-pnl-toggle' data-sort-type='pnl-eur' title='Sort by € value'>€</span> / <span class='tabulator-pnl-toggle' data-sort-type='pnl-pct' title='Sort by % value'>%</span>",
                            field: "pnl_absolute",
                            hozAlign: "right",
                            headerSort: false,
                            widthGrow: 1.2,
                            sorter: function(a, b, aRow, bRow, column, dir, sorterParams) {
                                const aData = aRow.getData();
                                const bData = bRow.getData();
                                const sortByPct = tabulatorPnLSortState.type === 'pnl-pct';
                                const aVal = sortByPct ? aData.pnl_percentage : aData.pnl_absolute;
                                const bVal = sortByPct ? bData.pnl_percentage : bData.pnl_absolute;
                                // Handle null/undefined - treat as -Infinity (sort to bottom in desc)
                                const aSafe = (aVal === null || aVal === undefined) ? -Infinity : aVal;
                                const bSafe = (bVal === null || bVal === undefined) ? -Infinity : bVal;
                                return aSafe - bSafe;
                            },
                            formatter: function(cell) {
                                const data = cell.getRow().getData();
                                return formatPnL(data.pnl_absolute, data.pnl_percentage, data.total_invested);
                            }
                        }
                    ];
                }

                // Inject Cash row when toggle is ON
                if (includeCash && cashBalance > 0) {
                    if (isStocksMode) {
                        tableData.push({
                            name: 'Cash',
                            sector: 'Cash',
                            percentage: cashPct,
                            total_value: cashBalance,
                            pnl_absolute: null,
                            pnl_percentage: null,
                            total_invested: null
                        });
                    } else {
                        // Thesis/Sector/Portfolios: top-level group with no children
                        tableData.push({
                            name: 'Cash',
                            percentage: cashPct,
                            total_value: cashBalance,
                            pnl_absolute: null,
                            pnl_percentage: null,
                            total_invested: null,
                            _children: []
                        });
                    }
                }

                // If table exists and same mode, just update data
                if (allocationTable && allocationTable._lastMode === allocationMode) {
                    selectedRow = null;
                    allocationTable.setData(tableData);
                    return;
                }

                // Destroy existing table if it exists
                if (allocationTable) {
                    allocationTable.destroy();
                    allocationTable = null;
                    selectedRow = null;
                }

                // Create Tabulator instance with appropriate config
                const config = {
                    data: tableData,
                    layout: "fitColumns",
                    placeholder: emptyMessage,
                    columns: columns,
                    selectableRows: 1
                };

                // Add tree config for portfolios/thesis/sector modes (not stocks)
                if (!isStocksMode) {
                    config.dataTree = true;
                    config.dataTreeStartExpanded = false;
                    config.dataTreeChildField = "_children";
                    config.dataTreeChildIndent = 15;
                }

                allocationTable = new Tabulator("#allocationTable", config);
                allocationTable._lastMode = allocationMode; // Track mode for optimization

                // Click any row to load its performance chart
                allocationTable.on("rowClick", function(e, row) {
                    // Let tree control clicks pass through to native expand/collapse
                    if (e.target.closest('.tabulator-data-tree-control')) return;

                    const data = row.getData();

                    // Ignore Cash rows
                    if (data.name === 'Cash') return;

                    // Toggle off: clicking already-selected row deselects and clears chart
                    if (selectedRow === row) {
                        row.deselect();
                        selectedRow = null;
                        clearPerformanceChart();
                        return;
                    }

                    // Deselect previous row, select new one
                    if (selectedRow) {
                        try { selectedRow.deselect(); } catch(e) {}
                    }
                    row.select();
                    selectedRow = row;

                    // Determine if this is a parent row (has _children) or a leaf/stock row
                    const isParent = !isStocksMode && !row.getTreeParent();
                    if (isParent) {
                        // Parent row: aggregate children identifiers
                        const children = row.getTreeChildren().map(c => c.getData());
                        const withIdentifiers = children.filter(c => c.identifier);
                        if (withIdentifiers.length > 0) {
                            loadPerformanceChart(
                                withIdentifiers.map(c => c.identifier),
                                withIdentifiers.map(c => c.name),
                                data.name,
                                withIdentifiers.map(c => c.current_value || 0)
                            );
                        } else {
                            showNoTickerMessage(data.name);
                        }
                    } else {
                        // Stock row (child in tree mode, or flat in stocks mode)
                        if (data.identifier) {
                            loadPerformanceChart(
                                [data.identifier],
                                [data.name],
                                data.name,
                                [data.current_value || 0]
                            );
                        } else {
                            showNoTickerMessage(data.name);
                        }
                    }
                });

                // Initialize P&L sort toggles in Tabulator header
                initTabulatorPnLSorting();
            }

            // Track current sort state for Tabulator P&L column
            let tabulatorPnLSortState = { type: null, direction: 'none' };

            function initTabulatorPnLSorting() {
                // Wait a tick for Tabulator to render the header
                setTimeout(() => {
                    document.querySelectorAll('#allocationTable .tabulator-pnl-toggle').forEach(toggle => {
                        // Skip if already initialized
                        if (toggle.dataset.initialized === 'true') return;
                        toggle.dataset.initialized = 'true';

                        toggle.addEventListener('click', function(e) {
                            e.stopPropagation(); // Prevent Tabulator's default header behavior

                            const sortType = this.dataset.sortType; // 'pnl-eur' or 'pnl-pct'
                            // Always use pnl_absolute as the field - custom sorter reads tabulatorPnLSortState.type
                            const field = 'pnl_absolute';

                            // Determine new direction
                            let newDirection = 'desc'; // Default to descending (highest first)
                            if (tabulatorPnLSortState.type === sortType) {
                                newDirection = tabulatorPnLSortState.direction === 'asc' ? 'desc' : 'asc';
                            }

                            // Update state
                            tabulatorPnLSortState = { type: sortType, direction: newDirection };

                            // Update visual indicators
                            document.querySelectorAll('#allocationTable .tabulator-pnl-toggle').forEach(t => {
                                t.classList.remove('pnl-sort-active', 'pnl-sort-asc', 'pnl-sort-desc');
                            });
                            this.classList.add('pnl-sort-active');
                            this.classList.add(newDirection === 'asc' ? 'pnl-sort-asc' : 'pnl-sort-desc');

                            // Sort Tabulator
                            if (allocationTable) {
                                allocationTable.setSort(field, newDirection);
                            }
                        });
                    });
                }, 50);
            }

            function initAllocationToggle() {
                const toggleGroup = document.getElementById('allocationToggle');
                if (!toggleGroup) return;

                toggleGroup.addEventListener('click', (e) => {
                    const btn = e.target.closest('.toggle-btn');
                    if (!btn) return;
                    btn.blur(); // Remove focus to prevent scroll jump from :focus-visible outline

                    const mode = btn.dataset.mode;
                    if (mode === allocationMode) return; // No change

                    // Update active state
                    toggleGroup.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update mode
                    allocationMode = mode;

                    // Clear performance chart on mode switch
                    clearPerformanceChart();

                    // Render the appropriate table
                    renderAllocationTable();
                });
            }

            // Unified allocation table rendering based on mode
            function renderAllocationTable() {
                const titleEl = document.getElementById('allocationTableTitle');

                // Update title based on mode
                if (allocationMode === 'stocks') {
                    titleEl.textContent = 'Stock Allocation';
                } else if (allocationMode === 'portfolios') {
                    titleEl.textContent = 'Portfolio Allocation';
                } else if (allocationMode === 'thesis') {
                    titleEl.textContent = 'Thesis Allocation';
                } else {
                    titleEl.textContent = 'Sector Allocation';
                }

                // Destroy existing table if mode changed (columns are different)
                if (allocationTable && allocationTable._lastMode !== allocationMode) {
                    allocationTable.destroy();
                    allocationTable = null;
                }

                // Render with unified Tabulator
                renderUnifiedTable();
            }

            function initHeatmapToggle() {
                const toggleGroup = document.getElementById('heatmapToggle');
                if (!toggleGroup) return;

                toggleGroup.addEventListener('click', (e) => {
                    const btn = e.target.closest('.toggle-btn');
                    if (!btn) return;
                    btn.blur(); // Remove focus to prevent scroll jump from :focus-visible outline

                    const mode = btn.dataset.mode;
                    if (mode === heatmapMode) return; // No change

                    // Update active state
                    toggleGroup.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update mode, title, and re-render heatmap
                    heatmapMode = mode;
                    document.getElementById('heatmapTitle').textContent =
                        mode === 'sector' ? 'Sector vs Country' : 'Thesis vs Country';

                    const heatmapData = calculateExposureData(selectedPortfolioIds, mode);
                    renderHeatmap(heatmapData, mode, 'sectorHeatmap');
                });
            }

            // Re-render charts when theme changes to update colors
            function setupThemeChangeHandler() {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.attributeName === 'data-theme') {
                            // Re-render heatmap with new theme colors
                            if (selectedPortfolioIds.length > 0) {
                                const heatmapData = calculateExposureData(selectedPortfolioIds, heatmapMode);
                                renderHeatmap(heatmapData, heatmapMode, 'sectorHeatmap');
                            }
                            // Re-render performance chart with new theme colors
                            const cacheKey = getChartCacheKey(currentChartIdentifiers);
                            if (performanceChartInstance && historicalDataCache.has(cacheKey)) {
                                renderPerformanceChart(historicalDataCache.get(cacheKey), currentChartNames, currentChartGroupName, currentChartValues);
                            }
                        }
                    });
                });

                observer.observe(document.documentElement, { attributes: true });
            }

            async function savePortfolioSelection(portfolioId) {
                // Save to global state for cross-page persistence
                await PortfolioState.setSelectedPortfolio(portfolioId);
            }

            async function loadSavedPortfolioSelection() {
                // Load from global state for cross-page persistence
                return await PortfolioState.getSelectedPortfolio();
            }

            function hidePortfolioDisplay() {
                document.getElementById('portfolioSummary').style.display = 'none';
                document.getElementById('portfolioTables').style.display = 'none';
                currentPortfolioData = null;

                // Clean up Tabulator table
                if (allocationTable) {
                    allocationTable.destroy();
                    allocationTable = null;
                }
            }

            function showLoadingState() {
                const tables = document.getElementById('portfolioTables');
                if (tables) {
                    tables.style.opacity = '0.5';
                    tables.style.pointerEvents = 'none';
                }
            }

            function hideLoadingState() {
                const tables = document.getElementById('portfolioTables');
                if (tables) {
                    tables.style.opacity = '';
                    tables.style.pointerEvents = '';
                }
            }

            function showError(message) {
                document.getElementById('loadingIndicator').innerHTML = `
                    <div class="has-text-centered">
                        <p class="has-text-danger mb-3">
                            <i class="fas fa-exclamation-triangle mr-2"></i>
                            ${escapeHtml(message)}
                        </p>
                        <button class="button is-info" onclick="location.reload()">Try Again</button>
                    </div>
                `;
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // ======================================================
            // Performance Chart Functions
            // ======================================================

            function showChartLoading() {
                document.getElementById('performanceChart').style.display = 'none';
                document.getElementById('performanceChartEmpty').style.display = 'none';
                document.getElementById('performanceChartLoading').style.display = '';
            }

            function hideChartLoading() {
                document.getElementById('performanceChartLoading').style.display = 'none';
            }

            function clearPerformanceChart() {
                if (performanceChartInstance) {
                    performanceChartInstance.destroy();
                    performanceChartInstance = null;
                }
                document.getElementById('performanceChart').style.display = 'none';
                document.getElementById('performanceChartLoading').style.display = 'none';
                const emptyEl = document.getElementById('performanceChartEmpty');
                emptyEl.style.display = '';
                emptyEl.innerHTML = '<p class="has-text-grey"><i class="fas fa-chart-line mr-2"></i>Click a row to see performance over time</p>';
                document.getElementById('performanceChartTitle').textContent = 'Returns';
                currentChartIdentifiers = [];
                currentChartNames = [];
                currentChartValues = [];
                currentChartGroupName = '';
                // Clear row selection
                if (selectedRow) {
                    try { selectedRow.deselect(); } catch(e) {}
                    selectedRow = null;
                }
            }

            function showNoTickerMessage(name) {
                if (performanceChartInstance) {
                    performanceChartInstance.destroy();
                    performanceChartInstance = null;
                }
                document.getElementById('performanceChart').style.display = 'none';
                document.getElementById('performanceChartLoading').style.display = 'none';
                const emptyEl = document.getElementById('performanceChartEmpty');
                emptyEl.style.display = '';
                emptyEl.innerHTML = `<p class="has-text-grey"><i class="fas fa-chart-line mr-2"></i>No ticker available for ${escapeHtml(name)}</p>`;
                document.getElementById('performanceChartTitle').textContent = 'Returns';
                currentChartIdentifiers = [];
                currentChartNames = [];
                currentChartValues = [];
                currentChartGroupName = '';
            }

            function getChartCacheKey(identifiers) {
                // Compute a consistent cache key that accounts for since_purchase mode
                // Must match the key format used in loadPerformanceChart
                let keyPart = currentChartPeriod;
                if (currentChartPeriod === 'since_purchase') {
                    const info = getSincePurchaseDateInfo(identifiers);
                    if (info) {
                        const daysSince = (Date.now() - new Date(info.earliestDate).getTime()) / 86400000;
                        keyPart = daysSince < 30 ? '5y' : ('sd:' + info.earliestDate);
                    } else {
                        keyPart = '5y'; // Match loadPerformanceChart fallback
                    }
                }
                return identifiers.slice().sort().join(',') + '|' + keyPart;
            }

            function getSincePurchaseDateInfo(identifiers) {
                // Collect per-stock purchase dates and find earliest/latest
                if (!currentPortfolioData || !currentPortfolioData.companies) return null;

                const identifierSet = new Set(identifiers);
                const purchaseDates = {};
                let earliestDate = null;
                let latestDate = null;

                for (const company of currentPortfolioData.companies) {
                    if (!identifierSet.has(company.identifier)) continue;
                    if (!company.first_bought_date) continue;

                    const d = company.first_bought_date.substring(0, 10); // YYYY-MM-DD
                    purchaseDates[company.identifier] = d;

                    if (!earliestDate || d < earliestDate) earliestDate = d;
                    if (!latestDate || d > latestDate) latestDate = d;
                }

                if (!earliestDate) return null;

                return { earliestDate, latestDate, purchaseDates };
            }

            async function loadPerformanceChart(identifiers, names, groupName, values) {
                // Cancel any in-flight request
                if (chartAbortController) {
                    chartAbortController.abort();
                }
                chartAbortController = new AbortController();

                currentChartIdentifiers = identifiers;
                currentChartNames = names;
                currentChartValues = values || [];
                currentChartGroupName = groupName;

                document.getElementById('performanceChartTitle').textContent = groupName + ' Returns';
                showChartLoading();

                // Resolve "since_purchase" to a start_date or fall back to "max"
                let effectivePeriod = currentChartPeriod;
                let startDate = null;
                let sincePurchaseInfo = null;
                if (currentChartPeriod === 'since_purchase') {
                    sincePurchaseInfo = getSincePurchaseDateInfo(identifiers);
                    if (sincePurchaseInfo) {
                        const daysSince = (Date.now() - new Date(sincePurchaseInfo.earliestDate).getTime()) / 86400000;
                        console.log(`[SincePurchase] earliestDate=${sincePurchaseInfo.earliestDate}, daysSince=${daysSince.toFixed(1)}, company=${sincePurchaseInfo.earliestCompany || 'unknown'}`);
                        if (daysSince < 30) {
                            // Less than 30 days - too short for a meaningful "Since Purchase" chart
                            console.warn(`[SincePurchase] Only ${daysSince.toFixed(1)} days of history, falling back to 5y`);
                            sincePurchaseInfo = null;
                            effectivePeriod = '5y';
                        } else {
                            startDate = sincePurchaseInfo.earliestDate;
                        }
                    } else {
                        console.warn('[SincePurchase] No purchase dates available, falling back to 5y');
                        effectivePeriod = '5y'; // Fallback when no dates available
                    }
                }

                // Check frontend cache (use sd: prefix for since_purchase to match getChartCacheKey)
                const cacheKeyPart = startDate ? ('sd:' + startDate) : effectivePeriod;
                const cacheKey = identifiers.slice().sort().join(',') + '|' + cacheKeyPart;
                if (historicalDataCache.has(cacheKey)) {
                    hideChartLoading();
                    renderPerformanceChart(historicalDataCache.get(cacheKey), names, groupName, values, sincePurchaseInfo);
                    return;
                }

                try {
                    const params = new URLSearchParams({
                        identifiers: identifiers.join(',')
                    });
                    if (startDate) {
                        params.set('start_date', startDate);
                    } else {
                        params.set('period', effectivePeriod);
                    }
                    const response = await fetch(`/portfolio/api/historical_prices?${params}`, {
                        signal: chartAbortController.signal
                    });

                    if (!response.ok) throw new Error('Failed to fetch historical data');
                    const data = await response.json();

                    // Cache the result
                    historicalDataCache.set(cacheKey, data);

                    hideChartLoading();
                    renderPerformanceChart(data, names, groupName, values, sincePurchaseInfo);

                } catch (error) {
                    if (error.name === 'AbortError') return; // Cancelled, ignore
                    console.error('Error loading performance chart:', error);
                    hideChartLoading();
                    document.getElementById('performanceChart').style.display = '';
                    document.getElementById('performanceChart').innerHTML =
                        '<div class="has-text-centered p-4"><p class="has-text-grey">Failed to load historical data</p></div>';
                }
            }

            function renderPerformanceChart(data, names, groupName, values, sincePurchaseInfo) {
                const chartEl = document.getElementById('performanceChart');
                chartEl.style.display = '';
                chartEl.innerHTML = '';

                const seriesData = data.series || {};
                const themeColors = ChartConfig.getThemeColors();

                // Build series: normalize each to base 100
                const allSeries = [];
                const identifiers = currentChartIdentifiers;

                for (let i = 0; i < identifiers.length; i++) {
                    const id = identifiers[i];
                    const name = names[i] || id;
                    let points = seriesData[id];
                    if (!points || points.length === 0) continue;

                    // In since_purchase mode, trim each stock to its own purchase date
                    let purchaseDate = null;
                    if (sincePurchaseInfo && sincePurchaseInfo.purchaseDates[id]) {
                        purchaseDate = sincePurchaseInfo.purchaseDates[id];
                        const cutoff = new Date(purchaseDate).getTime();
                        points = points.filter(p => new Date(p.date).getTime() >= cutoff);
                        if (points.length === 0) continue;
                    }

                    const basePrice = points[0].close;
                    if (basePrice === 0) continue;

                    allSeries.push({
                        name: name,
                        identifier: id,
                        value: (values && values[i]) || 0,
                        purchaseDate: purchaseDate,
                        data: points.map(p => ({
                            x: new Date(p.date).getTime(),
                            y: parseFloat(((p.close / basePrice) * 100).toFixed(2))
                        }))
                    });
                }

                if (allSeries.length === 0) {
                    chartEl.innerHTML =
                        '<div class="has-text-centered p-4"><p class="has-text-grey">No historical data available for ' + escapeHtml(groupName) + '</p></div>';
                    return;
                }

                // Build display series based on mode
                let displaySeries = [];
                const mode = currentChartMode;

                if (mode === 'detail') {
                    displaySeries = allSeries.map(s => ({
                        name: s.name,
                        data: s.data
                    }));
                }

                // Aggregate: solo line in aggregate mode, reference line in detail mode
                // Skip when only 1 series (aggregate would be identical to the stock itself)
                if (allSeries.length > 1) {
                    const aggSeries = computeAggregate(allSeries, sincePurchaseInfo);
                    if (aggSeries) {
                        displaySeries.push(aggSeries);
                    }
                } else if (mode === 'aggregate') {
                    // Single stock - just show it directly
                    displaySeries.push({
                        name: allSeries[0].name,
                        data: allSeries[0].data
                    });
                }

                // Colors
                // Colors — aggregate is yellow; individual lines use palette only (no colorMapping)
                const palette = ChartConfig.oceanDepthColors.palette;
                let paletteIdx = 0;
                const colors = displaySeries.map(s => {
                    if (s.name === 'Weighted Avg') return '#eab308'; // yellow — aggregate
                    return palette[paletteIdx++ % palette.length];
                });

                // Stroke config
                const strokeWidths = displaySeries.map(s => {
                    if (s.name === 'Weighted Avg') return 3;
                    return displaySeries.length > 8 ? 1.5 : 2;
                });
                const dashArray = displaySeries.map(s => s.name === 'Weighted Avg' ? 5 : 0);
                // Destroy previous chart
                if (performanceChartInstance) {
                    performanceChartInstance.destroy();
                    performanceChartInstance = null;
                }

                const options = {
                    series: displaySeries,
                    chart: {
                        type: 'area',
                        height: 350,
                        fontFamily: 'Inter, system-ui, -apple-system, sans-serif',
                        toolbar: { show: false },
                        zoom: { enabled: false },
                        background: 'transparent',
                        animations: { enabled: false }
                    },
                    colors: colors,
                    stroke: {
                        width: strokeWidths,
                        curve: 'smooth',
                        dashArray: dashArray
                    },
                    fill: {
                        type: mode === 'aggregate' ? 'solid' : 'gradient',
                        opacity: mode === 'aggregate' ? 0 : 0.05,
                        gradient: {
                            shade: 'light',
                            type: 'vertical',
                            opacityFrom: 0.08,
                            opacityTo: 0.01
                        }
                    },
                    dataLabels: { enabled: false },
                    grid: {
                        show: true,
                        borderColor: themeColors.textMuted + '20',
                        strokeDashArray: 4,
                        xaxis: { lines: { show: false } },
                        yaxis: { lines: { show: true } }
                    },
                    xaxis: {
                        type: 'datetime',
                        labels: {
                            style: { colors: themeColors.textTertiary, fontSize: '11px' }
                        },
                        axisBorder: { show: false },
                        axisTicks: { show: false }
                    },
                    yaxis: {
                        labels: {
                            style: { colors: themeColors.textTertiary, fontSize: '11px' },
                            formatter: v => v.toFixed(0),
                            offsetX: -8
                        }
                    },
                    tooltip: {
                        theme: themeColors.tooltipTheme,
                        x: { format: sincePurchaseInfo ? 'dd MMM yyyy' : 'MMM yyyy' },
                        y: {
                            formatter: function(val) {
                                const change = val - 100;
                                const sign = change >= 0 ? '+' : '';
                                return val.toFixed(1) + ' (' + sign + change.toFixed(1) + '%)';
                            }
                        }
                    },
                    legend: {
                        show: mode === 'detail' && displaySeries.length > 1,
                        position: 'top',
                        horizontalAlign: 'left',
                        labels: { colors: themeColors.textSecondary },
                        fontSize: '11px',
                        markers: { size: 4 },
                        itemMargin: { horizontal: 8 }
                    },
                    annotations: {
                        yaxis: [{
                            y: 100,
                            borderColor: themeColors.textMuted + '40',
                            strokeDashArray: 2,
                            label: { show: false }
                        }]
                    }
                };

                performanceChartInstance = new ApexCharts(chartEl, options);
                performanceChartInstance.render();
            }

            function computeAggregate(allSeries, sincePurchaseInfo) {
                if (allSeries.length === 0) return null;

                if (sincePurchaseInfo) {
                    return computeChainLinkedAggregate(allSeries);
                }
                return computeSimpleAggregate(allSeries);
            }

            function computeSimpleAggregate(allSeries) {
                // Weighted average by current portfolio value
                const totalValue = allSeries.reduce((sum, s) => sum + (s.value || 1), 0);
                const weights = allSeries.map(s => totalValue > 0 ? (s.value || 1) / totalValue : 1 / allSeries.length);

                // Collect all unique dates across all series
                const dateMap = new Map();
                allSeries.forEach((s, idx) => {
                    s.data.forEach(point => {
                        if (!dateMap.has(point.x)) {
                            dateMap.set(point.x, new Array(allSeries.length).fill(null));
                        }
                        dateMap.get(point.x)[idx] = point.y;
                    });
                });

                const sortedDates = Array.from(dateMap.keys()).sort((a, b) => a - b);

                // Forward-fill and compute weighted average
                const lastKnown = new Array(allSeries.length).fill(100);
                const hasData = new Array(allSeries.length).fill(false);
                const aggData = [];

                for (const date of sortedDates) {
                    const vals = dateMap.get(date);
                    let weightedSum = 0;
                    let weightSum = 0;

                    for (let i = 0; i < vals.length; i++) {
                        if (vals[i] !== null) { lastKnown[i] = vals[i]; hasData[i] = true; }
                        if (!hasData[i]) continue; // Skip stocks with no data yet
                        weightedSum += lastKnown[i] * weights[i];
                        weightSum += weights[i];
                    }

                    aggData.push({
                        x: date,
                        y: parseFloat((weightedSum / weightSum).toFixed(2))
                    });
                }

                return { name: 'Weighted Avg', data: aggData };
            }

            function computeChainLinkedAggregate(allSeries) {
                // Chain-linked aggregate: stocks enter the weighted average at their
                // purchase date without causing discontinuities.

                // Build per-series lookup: date -> normalized value (base 100)
                const seriesLookups = allSeries.map(s => {
                    const map = new Map();
                    s.data.forEach(p => map.set(p.x, p.y));
                    return map;
                });

                // Determine each series' start date (first data point)
                const seriesStartDates = allSeries.map(s => s.data[0].x);

                // Collect all unique dates, sorted
                const allDatesSet = new Set();
                allSeries.forEach(s => s.data.forEach(p => allDatesSet.add(p.x)));
                const sortedDates = Array.from(allDatesSet).sort((a, b) => a - b);

                if (sortedDates.length === 0) return null;

                // Portfolio weights by value
                const totalValue = allSeries.reduce((sum, s) => sum + (s.value || 1), 0);
                const weights = allSeries.map(s => totalValue > 0 ? (s.value || 1) / totalValue : 1 / allSeries.length);

                // Track previous known value per series (for computing period returns)
                const prevLevel = new Array(allSeries.length).fill(null);
                let aggregateLevel = 100;
                const aggData = [];

                for (const date of sortedDates) {
                    // Determine which series are active (have started and have data)
                    let totalActiveWeight = 0;
                    let weightedReturn = 0;

                    for (let i = 0; i < allSeries.length; i++) {
                        if (date < seriesStartDates[i]) continue; // Not yet active

                        const val = seriesLookups[i].get(date);
                        if (val == null) continue; // No data for this date

                        if (prevLevel[i] == null) {
                            // First data point for this series - enters at base 100
                            prevLevel[i] = val;
                            // Don't add to totalActiveWeight on entry: contributing 0 return
                            // with positive weight would dilute the aggregate
                        } else {
                            // Compute period return for this series
                            const periodReturn = (val - prevLevel[i]) / prevLevel[i];
                            weightedReturn += periodReturn * weights[i];
                            totalActiveWeight += weights[i];
                            prevLevel[i] = val;
                        }
                    }

                    if (totalActiveWeight > 0) {
                        // Normalize weighted return by active weight
                        const normalizedReturn = weightedReturn / totalActiveWeight;
                        aggregateLevel *= (1 + normalizedReturn);
                    }

                    aggData.push({
                        x: date,
                        y: parseFloat(aggregateLevel.toFixed(2))
                    });
                }

                return { name: 'Weighted Avg', data: aggData };
            }

            function initPeriodToggle() {
                const toggleGroup = document.getElementById('periodToggle');
                if (!toggleGroup) return;

                toggleGroup.addEventListener('click', (e) => {
                    const btn = e.target.closest('.toggle-btn');
                    if (!btn) return;
                    btn.blur();

                    const period = btn.dataset.period;
                    if (period === currentChartPeriod) return;

                    toggleGroup.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    currentChartPeriod = period;

                    // Reload chart if we have active identifiers
                    if (currentChartIdentifiers.length > 0) {
                        loadPerformanceChart(currentChartIdentifiers, currentChartNames, currentChartGroupName, currentChartValues);
                    }
                });
            }

            function initChartModeToggle() {
                const toggleGroup = document.getElementById('chartModeToggle');
                if (!toggleGroup) return;

                toggleGroup.addEventListener('click', (e) => {
                    const btn = e.target.closest('.toggle-btn');
                    if (!btn) return;
                    btn.blur();

                    const mode = btn.dataset.mode;
                    if (mode === currentChartMode) return;

                    toggleGroup.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    currentChartMode = mode;

                    // Re-render with same data if chart is showing
                    const cacheKey = getChartCacheKey(currentChartIdentifiers);
                    if (historicalDataCache.has(cacheKey)) {
                        let sincePurchaseInfo = null;
                        if (currentChartPeriod === 'since_purchase') {
                            sincePurchaseInfo = getSincePurchaseDateInfo(currentChartIdentifiers);
                        }
                        renderPerformanceChart(historicalDataCache.get(cacheKey), currentChartNames, currentChartGroupName, currentChartValues, sincePurchaseInfo);
                    }
                });
            }

            // END NEW INITIALIZATION LOGIC
            // ======================================================

            // Initialize with dropdown selector
            initializePage();

            // Get all companies from selected portfolios with additional metadata
            function getAllCompaniesFromSelectedPortfolios() {
                // Check if there are any selected portfolios
                if (selectedPortfolioIds.length === 0) {
                    return [];
                }

                const companies = portfolioData
                    .filter(p => selectedPortfolioIds.includes(p.id))
                    .flatMap(p => p.companies);

                // Ensure companies have calculated currentValue and metadata fields
                const result = companies.map(company => {
                    // Calculate currentValue using centralized utility (handles custom values)
                    if (typeof company.currentValue === 'undefined') {
                        company.currentValue = calculateItemValue(company);
                    }

                    // Ensure metadata fields exist
                    company.country = company.country || 'Unknown';
                    company.effective_country = company.effective_country || company.country || 'Unknown';
                    company.sector = company.sector || 'Unknown';

                    return company;
                });

                // Add virtual cash position when toggle is ON
                if (includeCash && cashBalance > 0) {
                    result.push({
                        id: 'cash-virtual',
                        name: 'Cash',
                        company: 'Cash',
                        currentValue: cashBalance,
                        sector: 'Cash',
                        thesis: 'Cash',
                        country: 'Cash',
                        effective_country: 'Cash',
                        investment_type: 'Cash'
                    });
                }

                return result;
            }

            // Group companies by name and sum values
            function groupCompaniesByName(companies) {
                const companyMap = {};

                companies.forEach(company => {
                    const name = company.name;
                    if (!companyMap[name]) {
                        companyMap[name] = {
                            name: name,
                            currentValue: 0,
                            shares: 0,
                            totalInvested: 0,
                            // Preserve metadata from the first occurrence
                            sector: company.sector || 'Unknown',
                            country: company.country || 'Unknown',

                        };
                    }

                    // Sum up values
                    companyMap[name].currentValue += company.currentValue || 0;
                    companyMap[name].shares += company.effective_shares || 0;
                    companyMap[name].totalInvested += company.totalInvested || 0;
                });

                // Convert to array and sort by value
                return Object.values(companyMap).sort((a, b) => b.currentValue - a.currentValue);
            }

            // Prepare chart data (labels and values)
            function prepareChartData(companies) {
                // Sort by value
                const sortedCompanies = [...companies].sort((a, b) => b.currentValue - a.currentValue);

                let labels = [];
                let values = [];

                if (sortedCompanies.length > 10) {
                    // Take top 10 companies
                    const top10 = sortedCompanies.slice(0, 10);
                    const others = sortedCompanies.slice(10);

                    labels = top10.map(c => c.name);
                    values = top10.map(c => c.currentValue);

                    // Add "Others" sector
                    const othersValue = others.reduce((sum, c) => sum + c.currentValue, 0);
                    if (othersValue > 0) {
                        labels.push('Others');
                        values.push(othersValue);
                    }
                } else {
                    labels = sortedCompanies.map(c => c.name);
                    values = sortedCompanies.map(c => c.currentValue);
                }

                return { labels, values };
            }

            // Use centralized color generation from ChartConfig
            window.generateColors = function (count) {
                return ChartConfig.generateColors(count);
            };


            // Render portfolio sections
            function renderPortfolioSections() {
                const container = document.getElementById('portfolioSections');
                if (!container) {
                    console.error('Portfolio sections container not found');
                    return;
                }

                // Clear existing content
                container.innerHTML = '';

                // Sort portfolios by name
                const sortedPortfolios = [...portfolioData].sort((a, b) => a.name.localeCompare(b.name));

                // Skip rendering if no portfolios to display
                if (sortedPortfolios.length === 0) {
                    container.innerHTML = '<div class="has-text-centered p-6">No portfolio data available</div>';
                    return;
                }

                // Track portfolios that were successfully rendered
                const renderedPortfolios = [];

                sortedPortfolios.forEach(portfolio => {
                    // Skip portfolios with no companies
                    if (!portfolio.companies || portfolio.companies.length === 0) {
                        return;
                    }

                    const section = document.createElement('div');
                    section.className = 'portfolio-section mb-5';
                    section.dataset.portfolioId = portfolio.id;
                    section.setAttribute('data-portfolio-name', portfolio.name);

                    const header = document.createElement('div');
                    header.className = 'portfolio-header';
                    header.innerHTML = `
                <div class="is-flex is-justify-content-space-between is-align-items-center">
                    <h4 class="portfolio-header-title">${portfolio.name}</h4>
                    <span class="icon toggle-portfolio">
                        <i class="fas fa-chevron-down"></i>
                    </span>
                </div>
            `;
                    header.style.cursor = 'pointer';

                    const content = document.createElement('div');
                    content.className = 'portfolio-content';

                    // Create the columns layout for company and category sections
                    const companiesColumns = document.createElement('div');
                    companiesColumns.className = 'columns';
                    companiesColumns.style.minHeight = '450px';

                    const sectorsColumns = document.createElement('div');
                    sectorsColumns.className = 'columns';
                    sectorsColumns.style.minHeight = '450px';

                    // Company table column
                    const companyTableColumn = document.createElement('div');
                    companyTableColumn.className = 'column is-6';
                    companyTableColumn.innerHTML = `
                <div class="table-container" style="height: 100%; display: flex; flex-direction: column;">
                    <table class="table is-fullwidth is-striped is-hoverable" data-table-id="companyTable">
                        <thead>
                            <tr>
                                <th class="is-sortable company-column" data-sort="string">Company</th>
                                <th class="is-sortable sector-column" data-sort="string">Sector</th>
                                <th class="is-sortable percentage-column" data-sort="number">%</th>
                                <th class="is-sortable value-column" data-sort="number">Current Value</th>
                                <th class="is-sortable value-column" data-sort="number">Total Invested</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${renderCompanyRows(portfolio)}
                        </tbody>
                    </table>
                </div>
            `;

                    // Category table column with info banner
                    const sectorTableColumn = document.createElement('div');
                    sectorTableColumn.className = 'column is-6';
                    sectorTableColumn.innerHTML = `
                <div class="table-container" style="height: calc(100% - 40px); display: flex; flex-direction: column;">
                    <table class="table is-fullwidth is-striped is-hoverable" data-table-id="sectorTable">
                        <thead>
                            <tr>
                                <th class="is-sortable company-column" data-sort="string">Sector</th>
                                <th class="is-sortable percentage-column" data-sort="number">%</th>
                                <th class="is-sortable value-column" data-sort="number">Current Value</th>
                                <th class="is-sortable value-column" data-sort="number">Total Invested</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${renderSectorRows(portfolio)}
                        </tbody>
                    </table>
                </div>
            `;

                    // Chart column for companies view
                    const companyChartColumn = document.createElement('div');
                    companyChartColumn.className = 'column is-6';
                    companyChartColumn.style.display = 'flex';
                    companyChartColumn.style.alignItems = 'center';

                    const companyChartContainer = document.createElement('div');
                    companyChartContainer.className = 'chart-medium-container';
                    companyChartContainer.style.display = 'flex';
                    companyChartContainer.style.alignItems = 'center';
                    companyChartContainer.style.justifyContent = 'center';
                    companyChartContainer.style.height = '100%';

                    const companyDiv = document.createElement('div');
                    companyDiv.id = `portfolioChart${portfolio.id}`;
                    companyDiv.style.width = '100%';
                    companyDiv.style.height = '100%';

                    companyChartContainer.appendChild(companyDiv);
                    companyChartColumn.appendChild(companyChartContainer);

                    // Chart column for categories view
                    const sectorChartColumn = document.createElement('div');
                    sectorChartColumn.className = 'column is-6';
                    sectorChartColumn.style.display = 'flex';
                    sectorChartColumn.style.alignItems = 'center';
                    sectorChartColumn.style.minHeight = '450px';

                    const sectorChartContainer = document.createElement('div');
                    sectorChartContainer.className = 'chart-medium-container';
                    sectorChartContainer.style.display = 'flex';
                    sectorChartContainer.style.alignItems = 'center';
                    sectorChartContainer.style.justifyContent = 'center';
                    sectorChartContainer.style.height = '100%';
                    sectorChartContainer.style.width = '100%';
                    sectorChartContainer.style.position = 'relative';

                    const sectorDiv = document.createElement('div');
                    sectorDiv.id = `sectorChart${portfolio.id}`;
                    sectorDiv.style.width = '100%';
                    sectorDiv.style.height = '450px';
                    sectorDiv.style.position = 'relative';
                    sectorDiv.style.visibility = 'visible';

                    sectorChartContainer.appendChild(sectorDiv);
                    sectorChartColumn.appendChild(sectorChartContainer);

                    // Assemble the sections
                    companiesColumns.appendChild(companyTableColumn);
                    companiesColumns.appendChild(companyChartColumn);

                    sectorsColumns.appendChild(sectorTableColumn);
                    sectorsColumns.appendChild(sectorChartColumn);

                    content.appendChild(companiesColumns);
                    content.appendChild(sectorsColumns);

                    // Set initial state to collapsed
                    content.style.display = 'none';

                    // Add header and content to section
                    section.appendChild(header);
                    section.appendChild(content);

                    // Add section to container
                    container.appendChild(section);

                    // Store portfolio reference for later chart initialization
                    renderedPortfolios.push(portfolio);

                    // FIX: Standardize portfolio header click handling using addEventListener instead of onclick
                    header.addEventListener('click', function () {
                        const content = section.querySelector('.portfolio-content');
                        const icon = section.querySelector('.toggle-portfolio i');

                        if (content.style.display === 'none') {
                            content.style.display = 'block';
                            icon.classList.remove('fa-chevron-down');
                            icon.classList.add('fa-chevron-up');

                            // Ensure charts render correctly when expanding
                            window.dispatchEvent(new Event('resize'));
                        } else {
                            content.style.display = 'none';
                            icon.classList.remove('fa-chevron-up');
                            icon.classList.add('fa-chevron-down');
                        }
                    });
                });

                // Initialize all charts after DOM is fully rendered
                setTimeout(() => {
                    renderedPortfolios.forEach(portfolio => {
                        try {
                            initializePortfolioChart(portfolio);
                            initializeSectorChart(portfolio);
                        } catch (error) {
                            console.error(`Error initializing chart for portfolio ${portfolio.id}:`, error);
                        }
                    });
                }, 100);
            }



            // Render company rows for a portfolio
            function renderCompanyRows(portfolio) {
                if (portfolio.companies.length === 0) {
                    return `<tr><td colspan="5" class="has-text-centered">No companies in this portfolio</td></tr>`;
                }

                return portfolio.companies.map(company => `
            <tr>
                <td>${company.name}</td>
                <td>${company.sector}</td>
                <td>${company.percentage ? formatPercentage(company.percentage) : '-'}</td>
                <td>${formatCurrency(company.currentValue)}</td>
                <td>${formatCurrency(company.totalInvested)}</td>
            </tr>
        `).join('');
            }

            // Render category rows for a portfolio
            function renderSectorRows(portfolio) {
                if (!portfolio.sectors || portfolio.sectors.length === 0) {
                    return `<tr><td colspan="4" class="has-text-centered">No categories in this portfolio</td></tr>`;
                }

                let html = '';

                portfolio.sectors.forEach(sector => {
                    // Main category row
                    html += `
                <tr class="sector-row" data-sector="${category.name}" data-portfolio-id="${portfolio.id}">
                    <td>
                        <span class="icon-text">
                            <span class="icon toggle-companies" data-sector="${category.name}" data-portfolio-id="${portfolio.id}">
                                <i class="fas fa-plus-circle"></i>
                            </span>
                            <span>${category.name}</span>
                        </span>
                    </td>
                    <td>${formatPercentage(category.percentage)}</td>
                    <td>${formatCurrency(category.currentValue)}</td>
                    <td>${formatCurrency(category.totalInvested)}</td>
                </tr>
            `;

                    // Company rows (initially hidden)
                    category.companies.forEach(company => {
                        // Calculate dual percentage representation:
                        // - What percentage of the category this company represents
                        // - What percentage of the portfolio this company represents
                        const portfolioPercentageText = formatPercentage(company.percentage);
                        const sectorPercentageText = formatPercentage(company.sectorPercentage);

                        html += `
                    <tr class="sector-companies is-hidden" data-parent-sector="${category.name}" data-portfolio-id="${portfolio.id}">
                        <td class="pl-5">
                            <span class="is-size-7">${company.name}</span>
                        </td>
                        <td>
                            <span class="is-size-7" title="Sector: ${sectorPercentageText} | Portfolio: ${portfolioPercentageText}">
                                ${sectorPercentageText}
                                <span class="has-text-grey-light">(${portfolioPercentageText} total)</span>
                            </span>
                        </td>
                        <td><span class="is-size-7">${formatCurrency(company.currentValue)}</span></td>
                        <td><span class="is-size-7">${formatCurrency(company.totalInvested)}</span></td>
                    </tr>
                `;
                    });
                });

                return html;
            }

            // Initialize chart for a specific portfolio
            function initializePortfolioChart(portfolio) {
                const elementId = `portfolioChart${portfolio.id}`;

                // Check if the element exists in the DOM
                const chartElement = document.getElementById(elementId);
                if (!chartElement) {
                    console.error(`Chart element not found: ${elementId}`);
                    return null;
                }

                // Prepare chart data for portfolio companies
                let { labels, values } = prepareChartData(portfolio.companies);

                // Skip chart creation if there's no data
                if (labels.length === 0 || values.length === 0) {
                    console.warn(`No data available for chart: ${elementId}`);
                    chartElement.innerHTML = '<div class="has-text-centered p-6">No data available</div>';
                    return null;
                }

                try {
                    // Create chart with consistent colors
                    if (typeof ChartConfig !== 'undefined' && ChartConfig.createStandardDoughnutChart) {
                        ChartConfig.createStandardDoughnutChart(
                            elementId,
                            labels,
                            values,
                            {
                                title: 'Companies',
                                showTotal: true,
                                height: 350
                                // Colors will be automatically assigned consistently based on labels
                            }
                        );

                        // Store reference
                        portfolioCharts[portfolio.id] = chartElement;
                        return chartElement;
                    } else {
                        console.error('ChartConfig.createStandardDoughnutChart not available');
                        chartElement.innerHTML = '<div class="has-text-centered p-6 has-text-danger">Chart library not available</div>';
                        return null;
                    }
                } catch (error) {
                    console.error(`Error creating chart for ${elementId}:`, error);
                    chartElement.innerHTML = '<div class="has-text-centered p-6 has-text-danger">Error creating chart</div>';
                    return null;
                }
            }

            // Initialize sector chart for a specific portfolio using sunburst
            function initializeSectorChart(portfolio) {
                const elementId = `sectorChart${portfolio.id}`;

                // Ensure the element exists
                const chartElement = document.getElementById(elementId);
                if (!chartElement) {
                    console.error(`Chart element not found: ${elementId}`);
                    return null;
                }

                // Check if portfolio has categories data
                if (!portfolio.sectors || portfolio.sectors.length === 0) {
                    console.warn(`No sector data available for portfolio ${portfolio.id}`);
                    chartElement.innerHTML = '<div class="has-text-centered p-6">No sector data available</div>';
                    return null;
                }

                // Ensure window.portfolioData is defined
                if (typeof window.portfolioData === 'undefined') {
                    console.error('window.portfolioData is undefined, setting it now');
                    window.portfolioData = [];
                }

                // Make sure this portfolio is in window.portfolioData
                // Store both as array element and as direct property
                if (!Array.isArray(window.portfolioData)) {
                    window.portfolioData = [];
                }

                // Add to array if not already present
                if (!window.portfolioData.find(p => p.id == portfolio.id)) {
                    window.portfolioData.push(portfolio);
                }

                // Also store by ID for direct access
                window.portfolioData[portfolio.id] = portfolio;

                // Clear any existing chart
                chartElement.innerHTML = '';

                try {
                    // Always set explicit dimensions with !important to override any conflicting styles
                    chartElement.style.setProperty('display', 'block', 'important');
                    chartElement.style.setProperty('height', '450px', 'important');
                    chartElement.style.setProperty('width', '100%', 'important');
                    chartElement.style.setProperty('position', 'relative', 'important');
                    chartElement.style.setProperty('visibility', 'visible', 'important');
                    chartElement.style.setProperty('opacity', '1', 'important');
                    chartElement.style.setProperty('min-height', '400px', 'important');
                    chartElement.style.setProperty('min-width', '300px', 'important');

                    // Also ensure parent containers are visible
                    let parent = chartElement.parentElement;
                    while (parent) {
                        const computedStyle = window.getComputedStyle(parent);
                        if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0') {
                            parent.style.setProperty('display', 'block', 'important');
                            parent.style.setProperty('visibility', 'visible', 'important');
                            parent.style.setProperty('opacity', '1', 'important');
                        }
                        parent = parent.parentElement;
                    }

                    // Force a reflow to ensure dimensions are applied
                    void chartElement.offsetHeight;

                    // Create the chart with a small delay to ensure the container is ready
                    setTimeout(() => {
                        try {
                            if (typeof ChartConfig !== 'undefined' && ChartConfig.createStandardDoughnutChart) {
                                // Create a simple doughnut chart showing sector breakdown
                                const sectorLabels = portfolio.sectors.map(cat => cat.name);
                                const sectorValues = portfolio.sectors.map(cat => cat.currentValue);

                                const chart = ChartConfig.createStandardDoughnutChart(
                                    elementId,
                                    sectorLabels,
                                    sectorValues,
                                    {
                                        title: 'Categories',
                                        showTotal: true,
                                        height: 350
                                        // Colors will be automatically assigned consistently based on labels
                                    }
                                );

                                // Store reference to the chart
                                if (chart) {
                                    if (!portfolioCharts.categories) {
                                        portfolioCharts.categories = {};
                                    }
                                    portfolioCharts.categories[portfolio.id] = chart;
                                    // Ensure the chart stays visible after creation
                                    setTimeout(() => {
                                        if (chartElement.offsetWidth === 0 || chartElement.offsetHeight === 0 ||
                                            chartElement.style.visibility === 'hidden' || chartElement.style.opacity === '0') {
                                            chartElement.style.setProperty('display', 'block', 'important');
                                            chartElement.style.setProperty('visibility', 'visible', 'important');
                                            chartElement.style.setProperty('opacity', '1', 'important');
                                        }
                                    }, 500);
                                } else {
                                    console.warn(`Failed to create sector chart for portfolio ${portfolio.id}`);
                                }
                            } else {
                                console.error('ChartConfig.createStandardDoughnutChart not available');
                                chartElement.innerHTML = '<div class="has-text-centered p-6 has-text-danger">Chart library not available</div>';
                            }
                        } catch (innerError) {
                            console.error(`Error in delayed chart creation for portfolio ${portfolio.id}:`, innerError);
                        }
                    }, 100);

                    return true; // Return success indicator
                } catch (error) {
                    console.error(`Error creating sunburst chart for portfolio ${portfolio.id}:`, error);
                    chartElement.innerHTML = '<div class="has-text-centered p-6 has-text-danger">Error creating chart</div>';
                    return null;
                }
            }


            // Render detailed overview section
            function renderDetailedOverview() {
                const container = document.getElementById('detailedOverview');

                // Calculate totals across all selected portfolios
                const selectedPortfolios = portfolioData.filter(p => selectedPortfolioIds.includes(p.id));
                const totalValue = selectedPortfolios.reduce((sum, p) => sum + p.totalValue, 0);
                const totalInvested = selectedPortfolios.reduce((sum, p) => sum + p.totalInvested, 0);
                const profitLoss = totalValue - totalInvested;
                const profitLossPercentage = totalInvested > 0 ? (profitLoss / totalInvested) * 100 : 0;

                // Get all companies from selected portfolios
                const allCompanies = getAllCompaniesFromSelectedPortfolios();
                const uniqueCompanies = new Set(allCompanies.map(c => c.name)).size;

                // Group by category
                const sectorGroups = {};
                allCompanies.forEach(company => {
                    const category = company.sector;

                    if (!sectorGroups[category]) {
                        sectorGroups[category] = {
                            name: category,
                            currentValue: 0,
                            totalInvested: 0,
                            count: 0
                        };
                    }

                    sectorGroups[category].currentValue += company.currentValue;
                    sectorGroups[category].totalInvested += company.totalInvested;
                    sectorGroups[category].count += 1;
                });

                // Sort categories by value
                const sortedSectors = Object.values(sectorGroups).sort((a, b) => b.currentValue - a.currentValue);

                // Render HTML
                container.innerHTML = `
            <div class="columns">
                <div class="column is-3">
                    <div class="box has-text-centered">
                        <p class="heading">Total Value</p>
                        <p class="title is-4">${formatCurrency(totalValue)}</p>
                    </div>
                </div>
                <div class="column is-3">
                    <div class="box has-text-centered">
                        <p class="heading">Total Invested</p>
                        <p class="title is-4">${formatCurrency(totalInvested)}</p>
                    </div>
                </div>
                <div class="column is-3">
                    <div class="box has-text-centered">
                        <p class="heading">Profit/Loss</p>
                        <p class="title is-4 ${profitLoss >= 0 ? 'has-text-success' : 'has-text-danger'}">
                            ${formatCurrency(profitLoss)} (${profitLossPercentage.toFixed(1)}%)
                        </p>
                    </div>
                </div>
                <div class="column is-3">
                    <div class="box has-text-centered">
                        <p class="heading">Unique Companies</p>
                        <p class="title is-4">${uniqueCompanies}</p>
                    </div>
                </div>
            </div>
            
            <h3 class="title is-5 mt-4">Sector Breakdown</h3>
            <div class="table-container">
                <table class="table is-fullwidth is-striped is-hoverable">
                    <thead>
                        <tr>
                            <th class="is-sortable company-column" data-sort="string">Sector</th>
                            <th class="is-sortable" data-sort="number">Companies</th>
                            <th class="is-sortable value-column" data-sort="number">Current Value</th>
                            <th class="is-sortable percentage-column" data-sort="number">%</th>
                            <th class="is-sortable value-column" data-sort="number">Total Invested</th>
                            <th class="is-sortable value-column" data-sort="number">Profit/Loss</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedSectors.map(category => {
                    const catProfitLoss = category.currentValue - category.totalInvested;
                    const catPercentage = totalValue > 0 ? (category.currentValue / totalValue) * 100 : 0;

                    return `<tr>
                                <td>${category.name}</td>
                                <td>${category.count}</td>
                                <td>${formatCurrency(category.currentValue)}</td>
                                <td>${formatPercentage(catPercentage)}</td>
                                <td>${formatCurrency(category.totalInvested)}</td>
                                <td class="${catProfitLoss >= 0 ? 'has-text-success' : 'has-text-danger'}">
                                    ${formatCurrency(catProfitLoss)}
                                </td>
                            </tr>`;
                }).join('')}
                    </tbody>
                </table>
            </div>
        `;
            }

            // New Risk Breakdown Functions

            // Helper function to get display country for geographic spread
            function getDisplayCountry(company) {
                // Check if this is a cryptocurrency based on identifier pattern
                const identifier = company.identifier || '';
                if (identifier.includes('-USD') || identifier.includes('BTC') || identifier.includes('ETH')) {
                    return 'Crypto';
                }

                // For non-crypto assets, use effective_country (includes user overrides)
                return (company.effective_country || '').trim() || 'Unknown';
            }

            // Calculate exposure data for heatmap with intelligent filtering
            function calculateExposureData(selectedPortfolioIds, dimension) {
                const allCompanies = getAllCompaniesFromSelectedPortfolios();

                // Handle case where there are no companies (e.g., no portfolios selected)
                if (!allCompanies || allCompanies.length === 0) {
                    return {
                        countries: [],
                        dims: [],
                        z: [],
                        companyDetails: {}, // Add company tracking
                        metadata: {
                            totalValue: 0,
                            countryPercentages: {},
                            dimensionPercentages: {}
                        }
                    };
                }

                const totalValue = allCompanies.reduce((sum, c) => sum + c.currentValue, 0);

                const exposure = {};
                const countryTotals = {}; // Track total per country for filtering
                const dimensionTotals = {}; // Track total per dimension for filtering
                const companyDetails = {}; // Track companies in each country×dimension cell

                // First pass: Collect all data points
                allCompanies.forEach(company => {
                    // Handle unknown values gracefully
                    const country = getDisplayCountry(company);
                    const dimValue = (company[dimension] || '').trim() || 'Unknown';

                    // Initialize if needed
                    if (!exposure[country]) exposure[country] = {};
                    if (!exposure[country][dimValue]) exposure[country][dimValue] = 0;
                    if (!countryTotals[country]) countryTotals[country] = 0;
                    if (!dimensionTotals[dimValue]) dimensionTotals[dimValue] = 0;

                    // Initialize company tracking
                    if (!companyDetails[country]) companyDetails[country] = {};
                    if (!companyDetails[country][dimValue]) companyDetails[country][dimValue] = [];

                    // Accumulate values
                    const value = company.currentValue || 0;
                    exposure[country][dimValue] += value;
                    countryTotals[country] += value;
                    dimensionTotals[dimValue] += value;

                    // Track company details for tooltip
                    companyDetails[country][dimValue].push({
                        name: company.name,
                        value: value,
                        percentage: 0 // Will be calculated later
                    });
                });

                // Handle edge case: if no valid exposure data was collected
                if (Object.keys(exposure).length === 0) {
                    return {
                        countries: [],
                        dims: [],
                        z: [],
                        companyDetails: {}, // Add company tracking
                        metadata: {
                            totalValue,
                            countryPercentages: {},
                            dimensionPercentages: {}
                        }
                    };
                }

                // Convert raw values to percentages
                for (const country in exposure) {
                    for (const dim in exposure[country]) {
                        exposure[country][dim] = totalValue > 0 ?
                            (exposure[country][dim] / totalValue) * 100 : 0;
                    }
                }

                // Calculate percentage thresholds for filtering
                const countryPercentages = {};
                const dimensionPercentages = {};

                for (const country in countryTotals) {
                    countryPercentages[country] = totalValue > 0 ?
                        (countryTotals[country] / totalValue) * 100 : 0;
                }

                for (const dim in dimensionTotals) {
                    dimensionPercentages[dim] = totalValue > 0 ?
                        (dimensionTotals[dim] / totalValue) * 100 : 0;
                }

                // Calculate individual company percentages for tooltips
                for (const country in companyDetails) {
                    for (const dim in companyDetails[country]) {
                        companyDetails[country][dim].forEach(company => {
                            company.percentage = totalValue > 0 ? (company.value / totalValue) * 100 : 0;
                        });
                        // Sort companies by value (descending)
                        companyDetails[country][dim].sort((a, b) => b.value - a.value);
                    }
                }

                // Filter out insignificant countries and dimensions (< 1% of portfolio)
                // but always keep at least the top 8 of each
                const significanceThreshold = 1.0; // Min percentage to display by default

                // Sort countries and dimensions by percentage (descending)
                let sortedCountries = Object.entries(countryPercentages)
                    .sort((a, b) => b[1] - a[1])
                    .map(entry => entry[0]);

                let sortedDimensions = Object.entries(dimensionPercentages)
                    .sort((a, b) => b[1] - a[1])
                    .map(entry => entry[0]);

                // Filter but keep at least top 8 countries (or all if fewer than 8)
                const topCountryCount = Math.min(8, sortedCountries.length);
                const topCountries = sortedCountries.slice(0, topCountryCount);
                sortedCountries = sortedCountries.filter(country =>
                    topCountries.includes(country) || countryPercentages[country] >= significanceThreshold
                );

                // Filter but keep at least top 8 dimensions (or all if fewer than 8)
                const topDimCount = Math.min(8, sortedDimensions.length);
                const topDimensions = sortedDimensions.slice(0, topDimCount);
                sortedDimensions = sortedDimensions.filter(dim =>
                    topDimensions.includes(dim) || dimensionPercentages[dim] >= significanceThreshold
                );

                // Remap 'Unknown' to be last if present
                const moveUnknownToEnd = arr => {
                    const idx = arr.indexOf('Unknown');
                    if (idx !== -1) {
                        arr.splice(idx, 1);
                        arr.push('Unknown');
                    }
                    return arr;
                };

                sortedCountries = moveUnknownToEnd(sortedCountries);
                sortedDimensions = moveUnknownToEnd(sortedDimensions);

                // Create z matrix for heatmap
                const z = sortedCountries.map(country =>
                    sortedDimensions.map(dim => exposure[country]?.[dim] || 0)
                );

                // Validate z matrix
                if (z.length === 0 || z[0].length === 0) {
                    console.warn(`Empty z matrix for ${dimension}:`, { countries: sortedCountries, dims: sortedDimensions });
                    return {
                        countries: [],
                        dims: [],
                        z: [],
                        companyDetails: {}, // Add company tracking
                        metadata: {
                            totalValue,
                            countryPercentages,
                            dimensionPercentages
                        }
                    };
                }

                // Return the optimized data for the heatmap
                return {
                    countries: sortedCountries,
                    dims: sortedDimensions,
                    z,
                    companyDetails, // Include company details
                    // Additional metadata for tooltips
                    metadata: {
                        totalValue,
                        countryPercentages,
                        dimensionPercentages
                    }
                };
            }

            function initializeRiskBreakdown() {
                try {
                    // Calculate data for current heatmap mode
                    const heatmapData = calculateExposureData(selectedPortfolioIds, heatmapMode);

                    // Get heatmap container
                    const heatmapContainer = document.querySelector('#sectorHeatmap');

                    // Render heatmap with a slight delay to ensure container is fully visible
                    setTimeout(() => {
                        try {
                            renderHeatmap(heatmapData, heatmapMode, 'sectorHeatmap');
                        } catch (heatmapError) {
                            console.error('Error rendering heatmap:', heatmapError);
                        }
                    }, 50);

                    // Calculate data for distribution charts
                    const countryDistribution = calculateExposureByDimension(selectedPortfolioIds, 'country');
                    const sectorDistribution = calculateExposureByDimension(selectedPortfolioIds, 'sector');

                    // Render bar charts with error handling
                    setTimeout(() => {
                        try {
                            renderDistributionBarChart('countryDistributionChart', countryDistribution, 'Country Distribution');
                            renderDistributionBarChart('sectorDistributionChart', sectorDistribution, 'Sector Distribution');
                        } catch (distributionError) {
                            console.error('Error rendering distribution charts:', distributionError);
                        }
                    }, 100);

                    // Initialize expandable sections with consistent event handling
                    initializeExpandableRiskSections();

                    // Force a resize of all charts after a short delay
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));
                    }, 200);

                } catch (error) {
                    console.error('Error in initializeRiskBreakdown:', error);
                    // Show error message in the main container if it exists
                    const element = document.getElementById('sectorHeatmap');
                    if (element) {
                        element.innerHTML =
                            '<div class="has-text-centered p-4"><p class="has-text-grey-light">Error rendering chart</p></div>';
                    }
                }
            }

            function renderHeatmap(data, dimensionName, elementId = 'riskHeatmap') {
                const chartElement = document.getElementById(elementId);
                if (!chartElement) {
                    console.error(`Heatmap element with ID '${elementId}' not found.`);
                    return;
                }
                // Destroy existing chart instance if any
                if (chartElement._apexChart) {
                    chartElement._apexChart.destroy();
                    chartElement._apexChart = null;
                }
                chartElement.innerHTML = ''; // Clear existing content

                if (!data || !data.z || data.z.length === 0 || !data.dims || data.dims.length === 0 || !data.countries || data.countries.length === 0) {
                    chartElement.innerHTML = '<div class="has-text-centered p-4">No data to display for this heatmap.</div>';
                    return;
                }

                // Detect dark mode for theme-aware colors
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

                const series = data.countries.map((country, index) => ({
                    name: country,
                    data: data.z[index].map(v => v.toFixed(2))
                }));

                const options = {
                    series: series,
                    chart: {
                        height: 450,
                        type: 'heatmap',
                        background: isDark ? '#0F172A' : '#ffffff', // Ocean 900 vs white
                        toolbar: {
                            show: true
                        },
                        animations: {
                            enabled: false
                        }
                    },
                    dataLabels: {
                        enabled: false
                    },
                    stroke: {
                        width: 1,
                        colors: [isDark ? '#0F172A' : '#ffffff']  // Match background for seamless grid
                    },
                    colors: [isDark ? '#06B6D4' : '#008FFB'], // Aqua for dark mode, blue for light
                    plotOptions: {
                        heatmap: {
                            shadeIntensity: isDark ? 0.9 : 0.5,  // Higher intensity for dark mode visibility
                            colorScale: {
                                ranges: isDark ? [
                                    { from: 0, to: 0, name: 'Empty', color: '#0F172A' },     // Ocean-900 (matches background)
                                    { from: 0.01, to: 5, name: 'Low', color: '#155E75' },    // Darker cyan
                                    { from: 5, to: 15, name: 'Medium', color: '#0891B2' },   // Mid cyan
                                    { from: 15, to: 30, name: 'High', color: '#06B6D4' },    // Aqua-500
                                    { from: 30, to: 100, name: 'Very High', color: '#22D3EE' } // Lighter aqua for max
                                ] : [
                                    { from: 0, to: 0, name: 'Empty', color: '#ffffff' },     // White (matches background)
                                    { from: 0.01, to: 5, name: 'Low', color: '#BFDBFE' },    // Light blue
                                    { from: 5, to: 15, name: 'Medium', color: '#60A5FA' },   // Mid blue
                                    { from: 15, to: 30, name: 'High', color: '#3B82F6' },    // Blue-500
                                    { from: 30, to: 100, name: 'Very High', color: '#1D4ED8' } // Darker blue for max
                                ]
                            }
                        }
                    },
                    xaxis: {
                        type: 'sector',
                        categories: data.dims,
                        labels: {
                            rotate: -45,
                            rotateAlways: true,
                            trim: true,
                            style: {
                                fontSize: '10px',
                                colors: isDark ? '#94A3B8' : '#333333' // Slate 400 for dark, dark gray for light
                            }
                        }
                    },
                    yaxis: {
                        labels: {
                            style: {
                                colors: isDark ? '#94A3B8' : '#333333' // Slate 400 for dark, dark gray for light
                            }
                        }
                    },
                    tooltip: {
                        custom: function ({ series, seriesIndex, dataPointIndex, w }) {
                            try {
                                const country = data.countries[seriesIndex] || 'Unknown';
                                const dimension = data.dims[dataPointIndex] || 'Unknown';
                                const value = series[seriesIndex][dataPointIndex] || 0;

                                // Get company details for this cell
                                const companies = data.companyDetails?.[country]?.[dimension] || [];

                                let companyList = '';
                                if (companies.length > 0) {
                                    // Show up to 10 companies, sorted by value
                                    const displayCount = Math.min(companies.length, 10);
                                    companyList = companies.slice(0, displayCount).map(company =>
                                        `<div style="margin: 2px 0; display: flex; justify-content: space-between;">
                                            <span style="margin-right: 8px;">${company.name}</span>
                                            <span style="font-weight: bold;">${company.percentage.toFixed(2)}%</span>
                                        </div>`
                                    ).join('');

                                    if (companies.length > displayCount) {
                                        companyList += `<div style="margin-top: 4px; font-style: italic; color: #888;">... and ${companies.length - displayCount} more</div>`;
                                    }
                                } else {
                                    companyList = '<div style="font-style: italic; color: #888;">No companies in this sector</div>';
                                }

                                return `<div style="padding: 12px; background: rgba(0,0,0,0.85); color: white; border-radius: 8px; font-size: 12px; max-width: 300px;">
                                    <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 4px;">
                                        ${country} × ${dimension}
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <strong>Total Allocation: ${Number(value).toFixed(2)}%</strong>
                                    </div>
                                    <div style="margin-bottom: 4px; font-weight: bold;">Companies (${companies.length}):</div>
                                    <div style="max-height: 200px; overflow-y: auto;">
                                        ${companyList}
                                    </div>
                                </div>`;
                            } catch (error) {
                                console.error('Tooltip error:', error);
                                return '<div style="padding: 8px;">Data unavailable</div>';
                            }
                        }
                    }
                };

                try {
                    const chart = new ApexCharts(chartElement, options);
                    chart.render();
                    chartElement._apexChart = chart; // Store reference for cleanup
                } catch (e) {
                    console.error(`Error rendering heatmap ${elementId}:`, e);
                    chartElement.innerHTML = '<div class="has-text-centered p-4 has-text-danger">Failed to render heatmap.</div>';
                }
            }

            // Calculate exposure by a single dimension for bar charts
            function calculateExposureByDimension(selectedPortfolioIds, dimension) {
                // Implementation of calculateExposureByDimension function
                return { labels: [], values: [], percentages: [] };
            }

            function renderBarChart(elementId, data, title) {
                // Implementation of renderBarChart function
            }

            // Render distribution bar charts
            function renderDistributionBarChart(elementId, data, title) {
                // Implementation of renderDistributionBarChart function
            }

            // Render doughnut charts using standardized formatting
            function renderDoughnutChart(elementId, data, title) {
                try {
                    // Handle both array format and object format with arrays
                    if (!data) {
                        console.warn(`Cannot render doughnut chart: Data is null or undefined for ${elementId}`);
                        document.getElementById(elementId).innerHTML =
                            '<div class="has-text-centered p-4"><p class="has-text-grey-light">No data available</p></div>';
                        return;
                    }

                    // Check if data is in the new format (object with arrays)
                    if (data.labels && Array.isArray(data.labels)) {
                        // New format - directly use the arrays
                        if (data.labels.length === 0) {
                            console.warn(`Cannot render doughnut chart: Empty labels array for ${elementId}`);
                            document.getElementById(elementId).innerHTML =
                                '<div class="has-text-centered p-4"><p class="has-text-grey-light">No data available</p></div>';
                            return;
                        }

                        // Use standardized chart configuration with consistent colors
                        ChartConfig.createStandardDoughnutChart(
                            elementId,
                            data.labels,
                            data.values,
                            {
                                title: title || '',
                                // Colors will be automatically assigned consistently based on labels
                                showTotal: true,
                                height: 350
                            }
                        );

                        return;
                    }

                    // Handle the old format (array of objects)
                    if (!Array.isArray(data) || data.length === 0) {
                        console.warn(`Cannot render doughnut chart: Invalid data format for ${elementId}`);
                        document.getElementById(elementId).innerHTML =
                            '<div class="has-text-centered p-4"><p class="has-text-grey-light">No data available</p></div>';
                        return;
                    }

                    // Prepare data for doughnut chart - take top 10 and group the rest as "Others"
                    let labels = [];
                    let values = [];

                    if (data.length > 10) {
                        // Take top 10 items
                        const top10 = data.slice(0, 10);
                        const others = data.slice(10);

                        labels = top10.map(d => d.name);
                        values = top10.map(d => d.value); // Use actual monetary values

                        // Add "Others" sector
                        const othersValue = others.reduce((sum, d) => sum + d.value, 0);
                        if (othersValue > 0) {
                            labels.push('Others');
                            values.push(othersValue);
                        }
                    } else {
                        labels = data.map(d => d.name);
                        values = data.map(d => d.value); // Use actual monetary values
                    }

                    // Use standardized chart configuration with consistent colors
                    ChartConfig.createStandardDoughnutChart(
                        elementId,
                        labels,
                        values,
                        {
                            title: title || '',
                            // Colors will be automatically assigned consistently based on labels
                            showTotal: true,
                            height: 350
                        }
                    );
                } catch (error) {
                    console.error(`Error in renderDoughnutChart for ${elementId}:`, error);
                    document.getElementById(elementId).innerHTML =
                        '<div class="has-text-centered p-4"><p class="has-text-grey-light">Error rendering chart</p></div>';
                }
            }

            // Initialize click handlers for heatmap section toggles
            function initializeHeatmapSectionToggle() {
                // Add click handlers specifically for heatmap section headers (those without data-portfolio-id)
                const heatmapSectionHeaders = document.querySelectorAll('.portfolio-section .portfolio-header');

                heatmapSectionHeaders.forEach(header => {
                    // Only handle sections that don't have data-portfolio-id (i.e., heatmap sections)
                    if (!header.closest('[data-portfolio-id]')) {
                        header.style.cursor = 'pointer';

                        // Ensure heatmap sections start collapsed by default
                        const section = header.closest('.portfolio-section');
                        const content = section.querySelector('.portfolio-content');
                        const icon = section.querySelector('.toggle-portfolio i');

                        if (content) {
                            content.style.display = 'none';
                        }
                        if (icon) {
                            icon.classList.remove('fa-chevron-up');
                            icon.classList.add('fa-chevron-down');
                        }

                        header.addEventListener('click', function () {
                            const section = this.closest('.portfolio-section');
                            const content = section.querySelector('.portfolio-content');
                            const icon = section.querySelector('.toggle-portfolio i');

                            if (content.style.display === 'none' || content.style.display === '') {
                                content.style.display = 'block';
                                icon.classList.remove('fa-chevron-down');
                                icon.classList.add('fa-chevron-up');

                                // Trigger chart rendering when section is expanded
                                window.dispatchEvent(new Event('resize'));
                            } else {
                                content.style.display = 'none';
                                icon.classList.remove('fa-chevron-up');
                                icon.classList.add('fa-chevron-down');
                            }
                        });
                    }
                });

            }

            // FIX: Initialize expandable sections for the Risk Breakdown using consistent event handling
            function initializeExpandableRiskSections() {
                // Implementation of initializeExpandableRiskSections function
            }

            // Add event listeners to toggle category companies - ENTIRE ROW CLICKABLE
            document.addEventListener('click', function (e) {
                // Check if click was on or inside a category row
                const sectorRow = e.target.closest('.sector-row');
                if (!sectorRow) return;

                const sectorName = sectorRow.dataset.sector;
                const portfolioId = sectorRow.dataset.portfolioId;

                // Find the toggle icon within this row
                const toggleIcon = sectorRow.querySelector('.toggle-companies');
                if (!toggleIcon) return;

                const icon = toggleIcon.querySelector('i');
                const isExpanding = icon.classList.contains('fa-plus-circle');

                // Toggle icon
                if (isExpanding) {
                    icon.classList.remove('fa-plus-circle');
                    icon.classList.add('fa-minus-circle');
                    sectorRow.classList.add('is-selected');
                } else {
                    icon.classList.remove('fa-minus-circle');
                    icon.classList.add('fa-plus-circle');
                    sectorRow.classList.remove('is-selected');
                }

                // Toggle company rows
                const companyRows = document.querySelectorAll(
                    `.sector-companies[data-parent-sector="${sectorName}"][data-portfolio-id="${portfolioId}"]`
                );

                companyRows.forEach(row => {
                    row.classList.toggle('is-hidden', !isExpanding);
                });
            });
        });
    </script>
    <!-- Styles moved to static/css/custom.css for consistency -->
    {% endblock %}